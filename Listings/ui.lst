C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UI
OBJECT MODULE PLACED IN .\Objects\ui.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\ui.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\driver;.\source) DEB
                    -UG OBJECTEXTEND PRINT(.\Listings\ui.lst) TABS(2) OBJECT(.\Objects\ui.obj)

line level    source

   1          #include "ui.h"
   2          #include "uart.h"
   3          #include "vars.h"
   4          #include "timer.h"
   5          #include "MYModBus.h"
   6          #include "string.h"
   7          #include "stdlib.h"
   8          
   9          void P0Func(void)
  10          {
  11   1        Contorl();
  12   1        Touch_Scan_0();
  13   1      }
  14          
  15          void P1Func(void) // 1
  16          {
  17   1        Polling1_6();
  18   1        Touch_Scan_1_2();
  19   1      }
  20          void P2Func(void)
  21          {
  22   1        Polling1_6();
  23   1        Touch_Scan_1_2();
  24   1      }
  25          
  26          void P3Func(void)
  27          {
  28   1        Touch_Scan_3();
  29   1        Coordinate_Control(); // 删除和确认
  30   1      
  31   1        File_Control(); // 读文件操作
  32   1      }
  33          void P4Func(void)
  34          {
  35   1        Touch_Scan_4();
  36   1      }
  37          
  38          void P5Func(void)
  39          {
  40   1        Touch_Scan_5();
  41   1        Touch_Scan_1_2();
  42   1      }
  43          void P6Func(void)
  44          {
  45   1        Polling1_6();
  46   1        Touch_Scan_6();
  47   1      }
  48          void P9Func(void)
  49          {
  50   1        gCtrlPara.Icon_InitFlag = 0;
  51   1        ; // 读状态标志
  52   1      
  53   1        gCtrlPara.VendxCount = 0; // 读Vendx标志
  54   1      
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 2   

  55   1        gCtrlPara.LED_NOWFlag = 1; // 读亮度标志
  56   1      }
  57          
  58          void P10_12Func(void)
  59          {
  60   1        Polling10_12();
  61   1        Touch_Scan_10_12();
  62   1      }
  63          
  64          void P13Func(void)
  65          {
  66   1        Touch_Scan_13();
  67   1      }
  68          
  69          void P14Func(void)
  70          {
  71   1        Touch_Scan_14();
  72   1      }
  73          
  74          // 密码
  75          void P16Func(void)
  76          {
  77   1        Touch_Scan_16();
  78   1      }
  79          
  80          // 锁-时间
  81          void P18Func(void)
  82          {
  83   1        //  Touch_Scan_18();
  84   1      }
  85          
  86          void P15_17Func(void)
  87          {
  88   1        Polling15_17();
  89   1      }
  90          code void (*PagePointer[])(u16 pageid) = {
  91            P0Func, P1Func, P2Func, P3Func, P4Func, P5Func, P6Func, 0, 0, P9Func, P10_12Func,
  92            0, P10_12Func, P13Func, P14Func, P15_17Func, P16Func, P15_17Func, P18Func};
  93          
  94          void PageFunction(void)
  95          {
  96   1        u16 pageid;
  97   1      
  98   1        EA = 0;
  99   1        ADR_H = 0x00;
 100   1        ADR_M = 0x00;
 101   1        ADR_L = 0x0a;
 102   1        ADR_INC = 1;
 103   1        RAMMODE = 0xAF; // ������
 104   1        while (!APP_ACK)
 105   1          ;
 106   1        APP_EN = 1;
 107   1        while (APP_EN)
 108   1          ;
 109   1        pageid = DATA3;
 110   1        pageid <<= 8;
 111   1        pageid |= DATA2;
 112   1        RAMMODE = 0;
 113   1        EA = 1;
 114   1        if (PagePointer[pageid] != 0)
 115   1        {
 116   2          PagePointer[pageid](pageid);
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 3   

 117   2        }
 118   1      }
 119          
 120          // 握手和数据显示
 121          void Contorl(void)
 122          {
 123   1        if (gCtrlPara.Shake_handFlag == 0)
 124   1        {
 125   2          gTime3++;
 126   2          if (gTime3 >= 50)
 127   2          {
 128   3            gTime3 = 0;
 129   3            HOST_Addr = HOST_Shake_hands;
 130   3            Send_ModBus(0x03, HOST_Shake_hands, 0x0000, 0x01); // 握手
 131   3      
 132   3            gCtrlPara.Cartoon = 0;                 // 动画
 133   3            sys_write_vp(0x100E, (u8 *)&gCtrlPara.Cartoon, 1); // 动画开始
 134   3      
 135   3            gCtrlPara.Cartoon = 1;                 // 动画
 136   3            sys_write_vp(0x100A, (u8 *)&gCtrlPara.Cartoon, 1); // 动画停止
 137   3            sys_write_vp(0x100C, (u8 *)&gCtrlPara.Cartoon, 1); // 动画停止
 138   3          }
 139   2        }
 140   1        else
 141   1        {
 142   2          if (gCtrlPara.PowerOn_ResetFlag == 0)
 143   2          {
 144   3            gTime3++;
 145   3            if (gTime3 >= 50)
 146   3            {
 147   4              gTime3 = 0;
 148   4              HOST_Addr = HOST_Power_On_Reset;
 149   4              Send_ModBus(0x03, HOST_Power_On_Reset, 0x0000, 0x01); // 复位
 150   4      
 151   4              gCtrlPara.Cartoon = 0;                 // 动画
 152   4              sys_write_vp(0x100C, (u8 *)&gCtrlPara.Cartoon, 1); // 动画开始
 153   4              //                sys_write_vp(0x100A,(u8*)&gCtrlPara.Cartoon,1);//动画开始
 154   4            }
 155   3          }
 156   2        }
 157   1      }
 158          
 159          // 轮询读取数据
 160          void Polling1_6(void)
 161          {
 162   1        if (gCtrlPara.Shake_handFlag == 1) // 握手成功读取数据
 163   1        {
 164   2          if (gCtrlPara.WorkSta == 0x0001) // 运行 run
 165   2          {
 166   3            switch (gCtrlPara.Flag)
 167   3            {
 168   4            case 0:
 169   4              HOST_Addr = HMI_WorkSta;
 170   4      
 171   4              Send_ModBus(0x03, HOST_WorkSta, 0x0000, 0x01); ////工作状态 working status
 172   4              gTime4++;
 173   4              if (gTime4 > 5)
 174   4              {
 175   5                gCtrlPara.Flag = 1;
 176   5                gTime4 = 0;
 177   5              }
 178   4              break;
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 4   

 179   4            case 1:
 180   4              HOST_Addr = HMI_Read_X_Value;
 181   4              Send_ModBus(0x03, HOST_Read_X_Value, 0x0000, 0x02); // 读X坐标
 182   4              gTime4++;
 183   4              if (gTime4 > 5)
 184   4              {
 185   5                gCtrlPara.Flag = 2;
 186   5                gTime4 = 0;
 187   5              }
 188   4              break;
 189   4            case 2:
 190   4              HOST_Addr = HMI_Read_Y_Value;
 191   4              Send_ModBus(0x03, HOST_Read_Y_Value, 0x0000, 0x02); // 读y坐标
 192   4              gTime4++;
 193   4              if (gTime4 > 5)
 194   4              {
 195   5                gCtrlPara.Flag = 3;
 196   5                gTime4 = 0;
 197   5              }
 198   4              break;
 199   4            case 3:
 200   4              HOST_Addr = HMI_Read_Z_Value;
 201   4              Send_ModBus(0x03, HOST_Read_Z_Value, 0x0000, 0x02); // 读Z坐标
 202   4              gTime4++;
 203   4              if (gTime4 > 5)
 204   4              {
 205   5                gCtrlPara.Flag = 4;
 206   5                gTime4 = 0;
 207   5              }
 208   4              break;
 209   4            case 4:
 210   4              HOST_Addr = HOST_Limit_Infor;
 211   4              Send_ModBus(0x03, HOST_Limit_Infor, 0x0000, 0x01); // 限位等报警信息
 212   4              gTime4++;
 213   4              if (gTime4 > 5)
 214   4              {
 215   5                gCtrlPara.Flag = 5;
 216   5                gTime4 = 0;
 217   5              }
 218   4              break;
 219   4            case 5:
 220   4              HOST_Addr = HMI_Work_TimeC;
 221   4              Send_ModBus(0x03, HOST_Work_TimeC, 0x0000, 0x01); // 加工时间0x001C-0x001E
 222   4              gTime4++;
 223   4              if (gTime4 > 5)
 224   4              {
 225   5                gCtrlPara.Flag = 6;
 226   5                gTime4 = 0;
 227   5              }
 228   4              break;
 229   4            case 6:
 230   4              HOST_Addr = HMI_Work_TimeD;
 231   4              Send_ModBus(0x03, HOST_Work_TimeD, 0x0000, 0x01); // 加工时间0x001C-0x001E
 232   4              gTime4++;
 233   4              if (gTime4 > 5)
 234   4              {
 235   5                gCtrlPara.Flag = 7;
 236   5                gTime4 = 0;
 237   5              }
 238   4              break;
 239   4            case 7:
 240   4              HOST_Addr = HMI_Work_TimeE;
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 5   

 241   4              Send_ModBus(0x03, HOST_Work_TimeE, 0x0000, 0x01); // 加工时间0x001C-0x001E
 242   4              gTime4++;
 243   4              if (gTime4 > 5)
 244   4              {
 245   5                gCtrlPara.Flag = 8;
 246   5                gTime4 = 0;
 247   5              }
 248   4              break;
 249   4            case 8:
 250   4              HOST_Addr = HMI_Processing_Speed;
 251   4              Send_ModBus(0x03, HOST_Processing_Speed, 0x0000, 0x01); // 加工速度
 252   4              gTime4++;
 253   4              if (gTime4 > 5)
 254   4              {
 255   5                gCtrlPara.Flag = 9;
 256   5                gTime4 = 0;
 257   5              }
 258   4              break;
 259   4            case 9:
 260   4              //                        HOST_Addr = HMI_U_Coordinate;
 261   4              //                        Send_ModBus(0x03,HOST_U_Coordinate,0x0000,0x04);//U显示
 262   4              gTime4++;
 263   4              if (gTime4 > 5)
 264   4              {
 265   5                gCtrlPara.Flag = 10;
 266   5                gTime4 = 0;
 267   5              }
 268   4      
 269   4              break;
 270   4            case 10:
 271   4              gCtrlPara.Flag = 0;
 272   4              break;
 273   4            }
 274   3          }
 275   2          // && (gCtrlPara.SendFlag <= 2)
 276   2          else if ((gCtrlPara.SendFlag == 1) && (gCtrlPara.WorkSta != 0x0001)) // 运行 run
 277   2          {
 278   3            switch (gCtrlPara.FreeFlag)
 279   3            {
 280   4            case 0:
 281   4              if (gCtrlPara.GO_Focusing == 1)
 282   4              {
 283   5                gCtrlPara.FreeFlag = 1;
 284   5              }
 285   4              else
 286   4              {
 287   5                HOST_Addr = HMI_WorkSta;
 288   5                Send_ModBus(0x03, HOST_WorkSta, 0x0000, 0x01); ////工作状态 working status
 289   5                gTime4++;
 290   5                if (gTime4 > 5)
 291   5                {
 292   6                  gCtrlPara.FreeFlag = 1;
 293   6                  gTime4 = 0;
 294   6                }
 295   5              }
 296   4              break;
 297   4            case 1:
 298   4              gCtrlPara.FreeFlag = 2;
 299   4              break;
 300   4            case 2:
 301   4              HOST_Addr = HMI_Read_X_Value;
 302   4              Send_ModBus(0x03, HOST_Read_X_Value, 0x0000, 0x02); // 读X坐标
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 6   

 303   4              gTime4++;
 304   4              if (gTime4 > 5)
 305   4              {
 306   5                gCtrlPara.FreeFlag = 3;
 307   5                gTime4 = 0;
 308   5              }
 309   4              break;
 310   4            case 3:
 311   4              HOST_Addr = HMI_Read_Y_Value;
 312   4              Send_ModBus(0x03, HOST_Read_Y_Value, 0x0000, 0x02); // 读y坐标
 313   4              gTime4++;
 314   4              if (gTime4 > 5)
 315   4              {
 316   5                gCtrlPara.FreeFlag = 4;
 317   5                gTime4 = 0;
 318   5              }
 319   4              break;
 320   4            case 4:
 321   4              HOST_Addr = HMI_Read_Z_Value;
 322   4              Send_ModBus(0x03, HOST_Read_Z_Value, 0x0000, 0x02); // 读Z坐标
 323   4              gTime4++;
 324   4              if (gTime4 > 5)
 325   4              {
 326   5                gCtrlPara.FreeFlag = 5;
 327   5                gTime4 = 0;
 328   5              }
 329   4              break;
 330   4            case 5:
 331   4              if (gCtrlPara.GO_Focusing == 1)
 332   4              {
 333   5                gCtrlPara.FreeFlag = 6;
 334   5              }
 335   4              else
 336   4              {
 337   5                HOST_Addr = HMI_Current_File_Name;
 338   5                Send_ModBus(0x03, HOST_Current_File_Name, 0x0000, 0x04); // 当前文件名0x0010-0x0013
 339   5                gTime4++;
 340   5                if (gTime4 > 5)
 341   5                {
 342   6                  gCtrlPara.FreeFlag = 6;
 343   6                  gTime4 = 0;
 344   6                }
 345   5              }
 346   4              break;
 347   4            case 6:
 348   4              if (gCtrlPara.GO_Focusing == 1)
 349   4              {
 350   5                HOST_Addr = HMI_Go_Border;
 351   5                Send_ModBus(0x03, HOST_Go_Border, 0x0000, 0x01); // 下发触控
 352   5              }
 353   4              else
 354   4              {
 355   5                gCtrlPara.FreeFlag = 7;
 356   5              }
 357   4              break;
 358   4            case 7:
 359   4              //                          HOST_Addr = HMI_U_Coordinate;
 360   4              //                          Send_ModBus(0x03,HOST_U_Coordinate,0x0000,0x04);//U显示
 361   4              gTime4++;
 362   4              if (gTime4 > 5)
 363   4              {
 364   5                gCtrlPara.FreeFlag = 8;
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 7   

 365   5                gTime4 = 0;
 366   5              }
 367   4      
 368   4              break;
 369   4      
 370   4            case 8:
 371   4              HOST_Addr = HOST_Limit_Infor;
 372   4              Send_ModBus(0x03, HOST_Limit_Infor, 0x0000, 0x01); // 限位等报警信息
 373   4              gTime4++;
 374   4              if (gTime4 > 5)
 375   4              {
 376   5                gCtrlPara.FreeFlag = 9;
 377   5                gTime4 = 0;
 378   5              }
 379   4              break;
 380   4            case 9:
 381   4              gCtrlPara.FreeFlag = 0;
 382   4              gCtrlPara.SendFlag++;
 383   4              break;
 384   4            }
 385   3          }
 386   2          else if (gCtrlPara.SendFlag > 1)
 387   2          {
 388   3            gCtrlPara.SendFlag++;
 389   3            if (gCtrlPara.SendFlag > 50)
 390   3            {
 391   4              gCtrlPara.SendFlag = 1;
 392   4            }
 393   3          }
 394   2        }
 395   1      }
 396          
 397          // 轮询读取数据
 398          void Polling2(void)
 399          {
 400   1        if (gCtrlPara.Shake_handFlag == 1) // 握手成功读取数据
 401   1        {
 402   2        }
 403   1      }
 404          
 405          void Polling10_12(void)
 406          {
 407   1        if (gCtrlPara.Shake_handFlag == 1) // 握手成功读取数据
 408   1        {
 409   2          if (gCtrlPara.VendxCount < 2)
 410   2          {
 411   3            switch (gCtrlPara.IconCount)
 412   3            {
 413   4            case 0:
 414   4              HOST_Addr = 0x0051;
 415   4              Send_ModBus(0x03, 0x0051, 0x0000, 0x01); // 下发触控
 416   4              gTime4++;
 417   4              if (gTime4 > 5)
 418   4              {
 419   5                gCtrlPara.IconCount = 1;
 420   5                gTime4 = 0;
 421   5              }
 422   4              break;
 423   4      
 424   4            case 1:
 425   4              HOST_Addr = 0x0052;
 426   4              Send_ModBus(0x03, 0x0052, 0x0000, 0x01); // 下发触控
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 8   

 427   4              gTime4++;
 428   4              if (gTime4 > 5)
 429   4              {
 430   5                gCtrlPara.IconCount = 2;
 431   5                gTime4 = 0;
 432   5              }
 433   4              break;
 434   4      
 435   4            case 2:
 436   4              HOST_Addr = 0x0053;
 437   4              Send_ModBus(0x03, 0x0053, 0x0000, 0x01); // 下发触控
 438   4              gTime4++;
 439   4              if (gTime4 > 5)
 440   4              {
 441   5                gCtrlPara.IconCount = 3;
 442   5                gTime4 = 0;
 443   5              }
 444   4              break;
 445   4      
 446   4            case 3:
 447   4              HOST_Addr = 0x0054;
 448   4              Send_ModBus(0x03, 0x0054, 0x0000, 0x01); // 下发触控
 449   4              gTime4++;
 450   4              if (gTime4 > 5)
 451   4              {
 452   5                gCtrlPara.IconCount = 4;
 453   5                gTime4 = 0;
 454   5              }
 455   4              break;
 456   4      
 457   4            case 4:
 458   4              HOST_Addr = 0x0055;
 459   4              Send_ModBus(0x03, 0x0055, 0x0000, 0x01); // 下发触控
 460   4              gTime4++;
 461   4              if (gTime4 > 5)
 462   4              {
 463   5                gCtrlPara.IconCount = 5;
 464   5                gTime4 = 0;
 465   5              }
 466   4              break;
 467   4      
 468   4            case 5:
 469   4              HOST_Addr = 0x0056;
 470   4              Send_ModBus(0x03, 0x0056, 0x0000, 0x01); // 下发触控
 471   4              gTime4++;
 472   4              if (gTime4 > 5)
 473   4              {
 474   5                gCtrlPara.IconCount = 6;
 475   5                gTime4 = 0;
 476   5              }
 477   4              break;
 478   4      
 479   4            case 6:
 480   4              gCtrlPara.IconCount = 0;
 481   4              gCtrlPara.VendxCount++;
 482   4              if (gCtrlPara.VendxCount > 1)
 483   4              {
 484   5                gCtrlPara.VendxCount = 2;
 485   5              }
 486   4              break;
 487   4            }
 488   3          }
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 9   

 489   2        }
 490   1      }
 491          
 492          void Polling15_17(void)
 493          {
 494   1      
 495   1        if (gCtrlPara.Shake_handFlag == 1) // 握手成功读取数据
 496   1        {
 497   2          if (gCtrlPara.VendxINFO < 2)
 498   2          {
 499   3            switch (gCtrlPara.IconCount)
 500   3            {
 501   4            case 0:
 502   4              HOST_Addr = 0x0032;
 503   4              Send_ModBus(0x03, 0x0032, 0x0000, 0x02); // 下发触控   主板信息
 504   4              gTime4++;
 505   4              if (gTime4 > 5)
 506   4              {
 507   5                gCtrlPara.IconCount = 1;
 508   5                gTime4 = 0;
 509   5              }
 510   4              break;
 511   4      
 512   4            case 1:
 513   4              HOST_Addr = 0x0465;
 514   4              Send_ModBus(0x03, 0x0465, 0x0000, 0x02); // 下发触控  累计开机时间
 515   4              gTime4++;
 516   4              if (gTime4 > 5)
 517   4              {
 518   5                gCtrlPara.IconCount = 2;
 519   5                gTime4 = 0;
 520   5              }
 521   4              break;
 522   4      
 523   4            case 2:
 524   4              HOST_Addr = 0x0467;
 525   4              Send_ModBus(0x03, 0x0467, 0x0000, 0x02); // 下发触控  累计加工时间
 526   4              gTime4++;
 527   4              if (gTime4 > 5)
 528   4              {
 529   5                gCtrlPara.IconCount = 3;
 530   5                gTime4 = 0;
 531   5              }
 532   4              break;
 533   4      
 534   4            case 3:
 535   4              HOST_Addr = 0x0469;
 536   4              Send_ModBus(0x03, 0x0469, 0x0000, 0x02); // 下发触控  前次加工时间
 537   4              gTime4++;
 538   4              if (gTime4 > 5)
 539   4              {
 540   5                gCtrlPara.IconCount = 4;
 541   5                gTime4 = 0;
 542   5              }
 543   4              break;
 544   4      
 545   4            case 4:
 546   4              HOST_Addr = 0x046B;
 547   4              Send_ModBus(0x03, 0x046B, 0x0000, 0x02); // 下发触控  累计出光时间
 548   4              gTime4++;
 549   4              if (gTime4 > 5)
 550   4              {
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 10  

 551   5                gCtrlPara.IconCount = 5;
 552   5                gTime4 = 0;
 553   5              }
 554   4              break;
 555   4      
 556   4            case 5:
 557   4              HOST_Addr = 0x046D;
 558   4              Send_ModBus(0x03, 0x046D, 0x0000, 0x02); // 下发触控   累计加工次数
 559   4              gTime4++;
 560   4              if (gTime4 > 5)
 561   4              {
 562   5                gCtrlPara.IconCount = 6;
 563   5                gTime4 = 0;
 564   5              }
 565   4              break;
 566   4      
 567   4              // 01 03 04 0A 00 01 A5 38
 568   4            case 6:
 569   4              HOST_Addr = 0x046F;
 570   4              Send_ModBus(0x03, 0x046F, 0x0000, 0x02); // 下发触控   X轴累计行程
 571   4              gTime4++;
 572   4              if (gTime4 > 5)
 573   4              {
 574   5                gCtrlPara.IconCount = 7;
 575   5                gTime4 = 0;
 576   5              }
 577   4              break;
 578   4      
 579   4            // 01 03 04 0B 00 01 F4 F8
 580   4            case 7:
 581   4              HOST_Addr = 0x0471;
 582   4              Send_ModBus(0x03, 0x0471, 0x0000, 0x02); // 下发触控  Y轴累计行程
 583   4              gTime4++;
 584   4              if (gTime4 > 5)
 585   4              {
 586   5                gCtrlPara.IconCount = 8;
 587   5                gTime4 = 0;
 588   5              }
 589   4              break;
 590   4      
 591   4              //                        //01 03 04 0C 00 02 05 38
 592   4              //                        case 8:
 593   4              //                            HOST_Addr = 0x040C;
 594   4              //                            Send_ModBus(0x03,0x040C,0x0000,0x04);//下发触控  系统锁定时间
 595   4              //                            gTime4++;
 596   4              //                            if(gTime4 >5)
 597   4              //                            {
 598   4              //                              gCtrlPara.IconCount = 9;
 599   4              //                              gTime4 = 0;
 600   4              //                            }
 601   4              //                          break;
 602   4      
 603   4            case 8:
 604   4      
 605   4              gCtrlPara.IconCount = 0;
 606   4              gCtrlPara.VendxINFO++;
 607   4              if (gCtrlPara.VendxINFO > 1)
 608   4              {
 609   5                gCtrlPara.VendxINFO = 2;
 610   5              }
 611   4              break;
 612   4            }
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 11  

 613   3          }
 614   2          else
 615   2          {
 616   3            gCtrlPara.VendxINFO++;
 617   3            if (gCtrlPara.VendxINFO > 200)
 618   3            {
 619   4              gCtrlPara.VendxINFO = 0;
 620   4            }
 621   3          }
 622   2        }
 623   1      }
 624          
 625          void Touch_Scan_0(void)
 626          {
 627   1        u8 i;
 628   1        // 停止复位
 629   1        for (i = 0; i < 5; i++)
 630   1        {
 631   2          sys_read_vp(RuiDa_ACS, (u8 *)&gCtrlPara.Stop, 1); // 读触控
 632   2        }
 633   1        if (gCtrlPara.Stop == 0x005A)
 634   1        {
 635   2          sys_read_vp(RuiDa_ACS, (u8 *)&gCtrlPara.Stop, 1); // 读触控
 636   2          if (gCtrlPara.Stop == 0x005A)
 637   2          {
 638   3            Send_ModBus(0x05, 0x0003, 0xFF00, 0x00); // 下发触控
 639   3            gCtrlPara.Stop = 0;
 640   3            sys_write_vp(RuiDa_ACS, (u8 *)&gCtrlPara.Stop, 1); // 触控清零
 641   3          }
 642   2        }
 643   1      }
 644          
 645          void Touch_Scan_3(void)
 646          {
 647   1        u8 i;
 648   1        u8 j;
 649   1        // 文件图标显示1
 650   1        for (i = 0; i < 7; i++)
 651   1        {
 652   2          sys_read_vp(HMI_Key_Control + i, (u8 *)&gCtrlPara.File_Icon, 1); // 读触控
 653   2      
 654   2          if (gCtrlPara.File_Icon == 0x0001)
 655   2          {
 656   3            for (j = 0; j < 7; j++)
 657   3            {
 658   4              sys_write_vp(HMI_File_Icon + j, (u8 *)&gCtrlPara.File_IconHis, 1); // 图标清零
 659   4            }
 660   3      
 661   3            sys_write_vp(HMI_File_Icon + i, (u8 *)&gCtrlPara.File_Icon, 1);       // 图标写1
 662   3            gCtrlPara.File_IconNum = i + 1;                       // 当前界面文件号
 663   3            gCtrlPara.File_Num = gCtrlPara.Number_Control * 7 + gCtrlPara.File_IconNum; // 选中文件标号
 664   3      
 665   3            sys_write_vp(HMI_Key_Control + i, (u8 *)&gCtrlPara.File_IconHis, 1); // 触控清零
 666   3          }
 667   2        }
 668   1      
 669   1        // 读当前控制页
 670   1        for (i = 0; i < 5; i++)
 671   1        {
 672   2          sys_read_vp(HMI_Current_Control, (u8 *)&gCtrlPara.Current_Control, 1);
 673   2        }
 674   1        if (gCtrlPara.Current_Control != gCtrlPara.Current_ControlHis)
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 12  

 675   1        {
 676   2          gCtrlPara.Number_Control = gCtrlPara.Current_Control - 1;
 677   2      
 678   2          if (gCtrlPara.Number_Control <= gCtrlPara.Integer)
 679   2          {
 680   3            gCtrlPara.FileFlag = 0; // 读文件标志
 681   3          }
 682   2          else
 683   2          {
 684   3            gCtrlPara.Current_ControlHis = gCtrlPara.Current_Control;
 685   3          }
 686   2      
 687   2          gCtrlPara.File_Num = gCtrlPara.Number_Control * 7 + gCtrlPara.File_IconNum; // 选中文件标号
 688   2        }
 689   1      }
 690          
 691          void Touch_Scan_4(void)
 692          {
 693   1      
 694   1        u8 i;
 695   1        gCtrlPara.FileFlag = 0; // 读文件标志
 696   1        gCtrlPara.Icon_InitFlag = 0;
 697   1        ;            // 读状态标志
 698   1        gCtrlPara.VendxINFO = 0; // 读INFO标志
 699   1      
 700   1        // 复位
 701   1        for (i = 0; i < 5; i++)
 702   1        {
 703   2          sys_read_vp(HMI_Reset_Enter, (u8 *)&gCtrlPara.Reset, 1); // 读触控
 704   2        }
 705   1        if (gCtrlPara.Reset == 0x0001)
 706   1        {
 707   2          sys_read_vp(HMI_Reset_Enter, (u8 *)&gCtrlPara.Reset, 1); // 读触控
 708   2          if (gCtrlPara.Reset == 0x0001)
 709   2          {
 710   3            gCtrlPara.Shake_handFlag = 0;
 711   3            gCtrlPara.PowerOn_ResetFlag = 0;
 712   3            Page_Change(0x00);
 713   3      
 714   3            gCtrlPara.Reset = 0;
 715   3            sys_write_vp(HMI_Reset_Enter, (u8 *)&gCtrlPara.Reset, 1); // 触控清零
 716   3          }
 717   2        }
 718   1      
 719   1        // 3301
 720   1        for (i = 0; i < 5; i++)
 721   1        {
 722   2          sys_read_vp(0x3301, (u8 *)&gCtrlPara.Reset, 1); // 读触控
 723   2        }
 724   1        if (gCtrlPara.Reset == 0x0001)
 725   1        {
 726   2          sys_read_vp(0x3301, (u8 *)&gCtrlPara.Reset, 1); // 读触控
 727   2          if (gCtrlPara.Reset == 0x0001)
 728   2          {
 729   3            Page_Change(0x08);
 730   3      
 731   3            gCtrlPara.Reset = 0;
 732   3            sys_write_vp(0x3301, (u8 *)&gCtrlPara.Reset, 1); // 触控清零
 733   3          }
 734   2        }
 735   1      
 736   1        // 读IP
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 13  

 737   1        for (i = 0; i < 5; i++)
 738   1        {
 739   2          sys_read_vp(HMI_Read_WIFI_IP, (u8 *)&gCtrlPara.Read_IP, 1); // 读触控
 740   2        }
 741   1        if (gCtrlPara.Read_IP == 0x005A)
 742   1        {
 743   2      
 744   2          sys_read_vp(HMI_Read_WIFI_IP, (u8 *)&gCtrlPara.Read_IP, 1); // 读触控
 745   2          if (gCtrlPara.Read_IP == 0x005A)
 746   2          {
 747   3            HOST_Addr = HMI_Read_WIFI_IP;
 748   3      
 749   3            Send_ModBus(0x03, HOST_Read_WIFI_IP, 0x0000, 0x04); // 下发触控
 750   3            gCtrlPara.Read_IP = 0;
 751   3            sys_write_vp(HMI_Read_WIFI_IP, (u8 *)&gCtrlPara.Read_IP, 1); // 触控清零
 752   3          }
 753   2        }
 754   1      }
 755          
 756          void Touch_Scan_5(void)
 757          {
 758   1        u8 i;
 759   1        // 点射(第一次)
 760   1        for (i = 0; i < 5; i++)
 761   1        {
 762   2          sys_read_vp(0x200B, (u8 *)&gCtrlPara.On, 1); // 读触控
 763   2        }
 764   1        if (gCtrlPara.On == 0x005A)
 765   1        {
 766   2          sys_read_vp(0x200B, (u8 *)&gCtrlPara.On, 1); // 读触控
 767   2          if (gCtrlPara.On == 0x005A)
 768   2          {
 769   3            gCtrlPara.TouchFlag = 1;
 770   3            Send_ModBus(0x05, 0x0013, 0xFF00, 0x00); // 下发触控
 771   3            gCtrlPara.On = 0;
 772   3            sys_write_vp(0x200B, (u8 *)&gCtrlPara.On, 1); // 触控清零
 773   3          }
 774   2        }
 775   1      
 776   1        // 点射（松开）
 777   1        for (i = 0; i < 5; i++)
 778   1        {
 779   2          sys_read_vp(0x200C, (u8 *)&gCtrlPara.On, 1); // 读触控
 780   2        }
 781   1        if (gCtrlPara.On == 0x005A)
 782   1        {
 783   2          sys_read_vp(0x200C, (u8 *)&gCtrlPara.On, 1); // 读触控
 784   2          if (gCtrlPara.On == 0x005A)
 785   2          {
 786   3            gCtrlPara.TouchFlag = 1;
 787   3            Send_ModBus(0x05, 0x0013, 0x0000, 0x00); // 下发触控
 788   3            gCtrlPara.On = 0;
 789   3            sys_write_vp(0x200C, (u8 *)&gCtrlPara.On, 1); // 触控清零
 790   3          }
 791   2        }
 792   1      }
 793          
 794          void Touch_Scan_1_2(void)
 795          {
 796   1      
 797   1        u8 i;
 798   1        gCtrlPara.FileFlag = 0; // 读文件标志
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 14  

 799   1      
 800   1        // 走边框  //0x1018
 801   1        for (i = 0; i < 5; i++)
 802   1        {
 803   2          sys_read_vp(HMI_Go_Border, (u8 *)&gCtrlPara.Go_Border, 1); // 读触控
 804   2        }
 805   1        if (gCtrlPara.Go_Border == 0x005A)
 806   1        {
 807   2          sys_read_vp(HMI_Go_Border, (u8 *)&gCtrlPara.Go_Border, 1); // 读触控
 808   2          if (gCtrlPara.Go_Border == 0x005A)
 809   2          {
 810   3            gCtrlPara.TouchFlag = 1;
 811   3            HOST_Addr = HMI_Go_Border;
 812   3            gCtrlPara.GO_Focusing = 1;
 813   3      
 814   3            Send_ModBus(0x05, HOST_Start_Go_Border, 0xFF00, 0x00); // 下发触控
 815   3            gCtrlPara.Go_Border = 0;
 816   3            sys_write_vp(HMI_Go_Border, (u8 *)&gCtrlPara.Go_Border, 1); // 触控清零
 817   3          }
 818   2        }
 819   1      
 820   1        // 定位点101B
 821   1        for (i = 0; i < 5; i++)
 822   1        {
 823   2          sys_read_vp(HMI_Anchor_Point, (u8 *)&gCtrlPara.Anchor_Point, 1); // 读触控
 824   2        }
 825   1        if (gCtrlPara.Anchor_Point == 0x005A)
 826   1        {
 827   2          sys_read_vp(HMI_Anchor_Point, (u8 *)&gCtrlPara.Anchor_Point, 1); // 读触控
 828   2          if (gCtrlPara.Anchor_Point == 0x005A)
 829   2          {
 830   3            Send_ModBus(0x05, HOST_Anchor_Point, 0xFF00, 0x00); // 下发触控
 831   3            gCtrlPara.Anchor_Point = 0;
 832   3            sys_write_vp(HMI_Anchor_Point, (u8 *)&gCtrlPara.Anchor_Point, 1); // 触控清零
 833   3          }
 834   2        }
 835   1      
 836   1        // 启动/暂停 start/pause
 837   1        for (i = 0; i < 5; i++)
 838   1        {
 839   2          sys_read_vp(HMI_Start_Stoptouch, (u8 *)&gCtrlPara.Start_Stoptouch, 1); // 读触控
 840   2        }
 841   1        if (gCtrlPara.Start_Stoptouch == 0x5A)
 842   1        {
 843   2          sys_read_vp(HMI_Start_Stoptouch, (u8 *)&gCtrlPara.Start_Stoptouch, 1); // 读触控
 844   2          if (gCtrlPara.Start_Stoptouch == 0x5A)
 845   2          {
 846   3            Send_ModBus(0x05, 0x0000, 0xFF00, 0x00); // 下发触控
 847   3            gCtrlPara.Start_Stoptouch = 0;
 848   3            sys_write_vp(HMI_Start_Stoptouch, (u8 *)&gCtrlPara.Start_Stoptouch, 1); // 触控清零
 849   3      
 850   3            gCtrlPara.SendFlag = 1;
 851   3            if ((gCtrlPara.WorkSta == 0) || (gCtrlPara.WorkSta == 3) || (gCtrlPara.WorkSta == 5))
 852   3            {
 853   4              //                      gCtrlPara.WorkSta = 1;//运行
 854   4              gCtrlPara.Start_Stop = 1;
 855   4              sys_write_vp(HMI_Start_Stop, (u8 *)&gCtrlPara.Start_Stop, 1); // 图标显示
 856   4            }
 857   3            else
 858   3            {
 859   4              //                      gCtrlPara.WorkSta = 3;//暂停
 860   4              gCtrlPara.Start_Stop = 0;
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 15  

 861   4              sys_write_vp(HMI_Start_Stop, (u8 *)&gCtrlPara.Start_Stop, 1); // 图标显示
 862   4            }
 863   3          }
 864   2        }
 865   1      
 866   1        // 停止(工作状态为空闲) stop (working status is idle)
 867   1        for (i = 0; i < 5; i++)
 868   1        {
 869   2          sys_read_vp(HMI_Stop, (u8 *)&gCtrlPara.Stop, 1); // 读触控
 870   2        }
 871   1        if (gCtrlPara.Stop == 1)
 872   1        {
 873   2          sys_read_vp(HMI_Stop, (u8 *)&gCtrlPara.Stop, 1); // 读触控
 874   2          if (gCtrlPara.Stop == 1)
 875   2          {
 876   3            Send_ModBus(0x05, 0x0003, 0xFF00, 0x00); // 下发触控
 877   3            gCtrlPara.Stop = 0;
 878   3            sys_write_vp(HMI_Stop, (u8 *)&gCtrlPara.Stop, 1); // 触控清零
 879   3            gCtrlPara.SendFlag = 1;
 880   3      
 881   3            gCtrlPara.Start_Stop = 0;
 882   3            sys_write_vp(HMI_Start_Stop, (u8 *)&gCtrlPara.Start_Stop, 1); // 图标显示
 883   3      
 884   3            gCtrlPara.WorkTimeH = 0;
 885   3            sys_write_vp(HMI_Work_TimeC, (u8 *)&gCtrlPara.WorkTimeH, 1);
 886   3            gCtrlPara.WorkTimeM = 0;
 887   3            sys_write_vp(HMI_Work_TimeD, (u8 *)&gCtrlPara.WorkTimeM, 1);
 888   3            gCtrlPara.WorkTimeS = 0;
 889   3            sys_write_vp(HMI_Work_TimeE, (u8 *)&gCtrlPara.WorkTimeS, 1);
 890   3      
 891   3            gCtrlPara.Processing_Speed = 0;
 892   3            sys_write_vp(HMI_Processing_Speed, (u8 *)&gCtrlPara.Processing_Speed, 1); // 加工速度显示
 893   3      
 894   3            Page_Change(0x01);
 895   3      
 896   3            //                    gCtrlPara.Cartoon = 0;//动画
 897   3            //                    sys_write_vp(HMI_Cartoon,(u8*)&gCtrlPara.Cartoon,1);//动画停止
 898   3      
 899   3            gCtrlPara.GO_Focusing = 0; // 走边框-寻焦
 900   3          }
 901   2        }
 902   1      
 903   1        /**********************************************************************************/
 904   1        if (gCtrlPara.Shake_handFlag == 1) // 握手成功读取数据
 905   1        {
 906   2          /* Arrow Keys Continuous Press Check */
 907   2          if (GetTimeOutFlag(ARROW_KEYS_TIMER_NO) && (gCtrlPara.arrowContPressFlag == 0))
 908   2          {
 909   3            Send_ModBus(0x05, gCtrlPara.arrowLastPressVal, 0xFF00, 0x00); // 下发触控
 910   3            delay_ms(50);
 911   3            gCtrlPara.arrowContPressFlag = 1;
 912   3          }
 913   2      
 914   2          // 上(第一次) Up First Press
 915   2          for (i = 0; i < 5; i++)
 916   2          {
 917   3            sys_read_vp(0x2002, (u8 *)&gCtrlPara.On, 1); // 读触控
 918   3          }
 919   2          if (gCtrlPara.On == 0x005A)
 920   2          {
 921   3            sys_read_vp(0x2002, (u8 *)&gCtrlPara.On, 1); // 读触控
 922   3            if (gCtrlPara.On == 0x005A)
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 16  

 923   3            {
 924   4              Send_ModBus(0x05, 0x0004, 0xFF00, 0x00); // 下发触控
 925   4              delay_ms(50);
 926   4              Send_ModBus(0x05, 0x0004, 0x0000, 0x00);
 927   4              gCtrlPara.On = 0;
 928   4              sys_write_vp(0x2002, (u8 *)&gCtrlPara.On, 1); // 触控清零
 929   4      
 930   4              gCtrlPara.arrowContPressFlag = 0;
 931   4              gCtrlPara.arrowLastPressVal = 0x0004;
 932   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
 933   4              gCtrlPara.SendFlag = 1;
 934   4            }
 935   3          }
 936   2      
 937   2          // 上（松开） Up Release
 938   2          for (i = 0; i < 5; i++)
 939   2          {
 940   3            sys_read_vp(0x2003, (u8 *)&gCtrlPara.On, 1); // 读触控
 941   3          }
 942   2          if (gCtrlPara.On == 0x005A)
 943   2          {
 944   3            sys_read_vp(0x2003, (u8 *)&gCtrlPara.On, 1); // 读触控
 945   3            if (gCtrlPara.On == 0x005A)
 946   3            {
 947   4              KillTimer(ARROW_KEYS_TIMER_NO);
 948   4              gCtrlPara.arrowLastPressVal = 0;
 949   4              gCtrlPara.arrowContPressFlag = 0;
 950   4              Send_ModBus(0x05, 0x0004, 0x0000, 0x00); // 下发触控
 951   4              gCtrlPara.On = 0;
 952   4              sys_write_vp(0x2003, (u8 *)&gCtrlPara.On, 1); // 触控清零
 953   4            }
 954   3          }
 955   2      
 956   2          // 下(第一次) Down First Press
 957   2          for (i = 0; i < 5; i++)
 958   2          {
 959   3            sys_read_vp(0x2004, (u8 *)&gCtrlPara.Under, 1); // 读触控
 960   3          }
 961   2          if (gCtrlPara.Under == 0x005A)
 962   2          {
 963   3            sys_read_vp(0x2004, (u8 *)&gCtrlPara.Under, 1); // 读触控
 964   3            if (gCtrlPara.Under == 0x005A)
 965   3            {
 966   4              Send_ModBus(0x05, 0x0005, 0xFF00, 0x00); // 下发触控
 967   4              delay_ms(50);
 968   4              Send_ModBus(0x05, 0x0005, 0x0000, 0x00);
 969   4              gCtrlPara.Under = 0;
 970   4              sys_write_vp(0x2004, (u8 *)&gCtrlPara.Under, 1); // 触控清零
 971   4      
 972   4              gCtrlPara.arrowContPressFlag = 0;
 973   4              gCtrlPara.arrowLastPressVal = 0x0005;
 974   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
 975   4              gCtrlPara.SendFlag = 1;
 976   4            }
 977   3          }
 978   2      
 979   2          // 下（松开） Down Release
 980   2          for (i = 0; i < 5; i++)
 981   2          {
 982   3            sys_read_vp(0x2005, (u8 *)&gCtrlPara.Under, 1); // 读触控
 983   3          }
 984   2          if (gCtrlPara.Under == 0x005A)
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 17  

 985   2          {
 986   3            sys_read_vp(0x2005, (u8 *)&gCtrlPara.Under, 1); // 读触控
 987   3            if (gCtrlPara.Under == 0x005A)
 988   3            {
 989   4              KillTimer(ARROW_KEYS_TIMER_NO);
 990   4              gCtrlPara.arrowLastPressVal = 0;
 991   4              gCtrlPara.arrowContPressFlag = 0;
 992   4              Send_ModBus(0x05, 0x0005, 0x0000, 0x00); // 下发触控
 993   4              gCtrlPara.Under = 0;
 994   4              sys_write_vp(0x2005, (u8 *)&gCtrlPara.Under, 1); // 触控清零
 995   4            }
 996   3          }
 997   2      
 998   2          // 左(第一次) Left First Press
 999   2          for (i = 0; i < 5; i++)
1000   2          {
1001   3            sys_read_vp(0x2006, (u8 *)&gCtrlPara.Left, 1); // 读触控
1002   3          }
1003   2          if (gCtrlPara.Left == 0x005A)
1004   2          {
1005   3            sys_read_vp(0x2006, (u8 *)&gCtrlPara.Left, 1); // 读触控
1006   3            if (gCtrlPara.Left == 0x005A)
1007   3            {
1008   4              Send_ModBus(0x05, 0x0006, 0xFF00, 0x00); // 下发触控
1009   4              delay_ms(10);
1010   4              Send_ModBus(0x05, 0x0006, 0x0000, 0x00);
1011   4              gCtrlPara.Left = 0;
1012   4              sys_write_vp(0x2006, (u8 *)&gCtrlPara.Left, 1); // 触控清零
1013   4      
1014   4              gCtrlPara.arrowContPressFlag = 0;
1015   4              gCtrlPara.arrowLastPressVal = 0x0006;
1016   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
1017   4              gCtrlPara.SendFlag = 1;
1018   4            }
1019   3          }
1020   2      
1021   2          // 左（松开） Left Release
1022   2          for (i = 0; i < 5; i++)
1023   2          {
1024   3            sys_read_vp(0x2007, (u8 *)&gCtrlPara.Left, 1); // 读触控
1025   3          }
1026   2          if (gCtrlPara.Left == 0x005A)
1027   2          {
1028   3            sys_read_vp(0x2007, (u8 *)&gCtrlPara.Left, 1); // 读触控
1029   3            if (gCtrlPara.Left == 0x005A)
1030   3            {
1031   4              KillTimer(ARROW_KEYS_TIMER_NO);
1032   4              gCtrlPara.arrowLastPressVal = 0;
1033   4              gCtrlPara.arrowContPressFlag = 0;
1034   4              Send_ModBus(0x05, 0x0006, 0x0000, 0x00); // 下发触控
1035   4              gCtrlPara.Left = 0;
1036   4              sys_write_vp(0x2007, (u8 *)&gCtrlPara.Left, 1); // 触控清零
1037   4            }
1038   3          }
1039   2      
1040   2          // 右(第一次) Right First Press
1041   2          for (i = 0; i < 5; i++)
1042   2          {
1043   3            sys_read_vp(0x2008, (u8 *)&gCtrlPara.Right, 1); // 读触控
1044   3          }
1045   2          if (gCtrlPara.Right == 0x005A)
1046   2          {
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 18  

1047   3            sys_read_vp(0x2008, (u8 *)&gCtrlPara.Right, 1); // 读触控
1048   3            if (gCtrlPara.Right == 0x005A)
1049   3            {
1050   4              Send_ModBus(0x05, 0x0007, 0xFF00, 0x00); // 下发触控
1051   4              delay_ms(10);
1052   4              Send_ModBus(0x05, 0x0007, 0x0000, 0x00);
1053   4              gCtrlPara.Right = 0;
1054   4              sys_write_vp(0x2008, (u8 *)&gCtrlPara.Right, 1); // 触控清零
1055   4      
1056   4              gCtrlPara.arrowContPressFlag = 0;
1057   4              gCtrlPara.arrowLastPressVal = 0x0007;
1058   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
1059   4              gCtrlPara.SendFlag = 1;
1060   4            }
1061   3          }
1062   2      
1063   2          // 右（松开） Right Release
1064   2          for (i = 0; i < 5; i++)
1065   2          {
1066   3            sys_read_vp(0x2009, (u8 *)&gCtrlPara.Right, 1); // 读触控
1067   3          }
1068   2          if (gCtrlPara.Right == 0x005A)
1069   2          {
1070   3            sys_read_vp(0x2009, (u8 *)&gCtrlPara.Right, 1); // 读触控
1071   3            if (gCtrlPara.Right == 0x005A)
1072   3            {
1073   4              KillTimer(ARROW_KEYS_TIMER_NO);
1074   4              gCtrlPara.arrowLastPressVal = 0;
1075   4              gCtrlPara.arrowContPressFlag = 0;
1076   4              Send_ModBus(0x05, 0x0007, 0x0000, 0x00); // 下发触控
1077   4              gCtrlPara.Right = 0;
1078   4              sys_write_vp(0x2009, (u8 *)&gCtrlPara.Right, 1); // 触控清零
1079   4            }
1080   3          }
1081   2      
1082   2          // Z轴正(第一次)
1083   2          for (i = 0; i < 5; i++)
1084   2          {
1085   3            sys_read_vp(0x200D, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1086   3          }
1087   2          if (gCtrlPara.Z_Positive == 0x005A)
1088   2          {
1089   3            sys_read_vp(0x200D, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1090   3            if (gCtrlPara.Z_Positive == 0x005A)
1091   3            {
1092   4              Send_ModBus(0x05, 0x0014, 0xFF00, 0x00); // 下发触控
1093   4              gCtrlPara.Z_Positive = 0;
1094   4              sys_write_vp(0x200D, (u8 *)&gCtrlPara.Z_Positive, 1); // 触控清零
1095   4      
1096   4              gCtrlPara.SendFlag = 1;
1097   4            }
1098   3          }
1099   2      
1100   2          // Z轴正（松开）
1101   2          for (i = 0; i < 5; i++)
1102   2          {
1103   3            sys_read_vp(0x200E, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1104   3          }
1105   2          if (gCtrlPara.Z_Positive == 0x005A)
1106   2          {
1107   3            sys_read_vp(0x200E, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1108   3            if (gCtrlPara.Z_Positive == 0x005A)
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 19  

1109   3            {
1110   4              Send_ModBus(0x05, 0x0014, 0x0000, 0x00); // 下发触控
1111   4              gCtrlPara.Z_Positive = 0;
1112   4              sys_write_vp(0x200E, (u8 *)&gCtrlPara.Z_Positive, 1); // 触控清零
1113   4            }
1114   3          }
1115   2      
1116   2          // Z轴负(第一次)
1117   2          for (i = 0; i < 5; i++)
1118   2          {
1119   3            sys_read_vp(0x200F, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1120   3          }
1121   2          if (gCtrlPara.Z_Peverse == 0x005A)
1122   2          {
1123   3            sys_read_vp(0x200F, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1124   3            if (gCtrlPara.Z_Peverse == 0x005A)
1125   3            {
1126   4              Send_ModBus(0x05, 0x0015, 0xFF00, 0x00); // 下发触控
1127   4              gCtrlPara.Z_Peverse = 0;
1128   4              sys_write_vp(0x200F, (u8 *)&gCtrlPara.Z_Peverse, 1); // 触控清零
1129   4      
1130   4              gCtrlPara.SendFlag = 1;
1131   4            }
1132   3          }
1133   2      
1134   2          // Z轴负（松开）
1135   2          for (i = 0; i < 5; i++)
1136   2          {
1137   3            sys_read_vp(0x2010, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1138   3          }
1139   2          if (gCtrlPara.Z_Peverse == 0x005A)
1140   2          {
1141   3            sys_read_vp(0x2010, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1142   3            if (gCtrlPara.Z_Peverse == 0x005A)
1143   3            {
1144   4              Send_ModBus(0x05, 0x0015, 0x0000, 0x00); // 下发触控
1145   4              gCtrlPara.Z_Peverse = 0;
1146   4              sys_write_vp(0x2010, (u8 *)&gCtrlPara.Z_Peverse, 1); // 触控清零
1147   4            }
1148   3          }
1149   2      
1150   2          // U轴正(第一次)
1151   2          for (i = 0; i < 5; i++)
1152   2          {
1153   3            sys_read_vp(0x2011, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1154   3          }
1155   2          if (gCtrlPara.U_Positive == 0x005A)
1156   2          {
1157   3            sys_read_vp(0x2011, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1158   3            if (gCtrlPara.U_Positive == 0x005A)
1159   3            {
1160   4              Send_ModBus(0x05, 0x0016, 0xFF00, 0x00); // 下发触控
1161   4              gCtrlPara.U_Positive = 0;
1162   4              sys_write_vp(0x2011, (u8 *)&gCtrlPara.U_Positive, 1); // 触控清零
1163   4      
1164   4              gCtrlPara.SendFlag = 1;
1165   4            }
1166   3          }
1167   2      
1168   2          // U轴正（松开）
1169   2          for (i = 0; i < 5; i++)
1170   2          {
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 20  

1171   3            sys_read_vp(0x2012, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1172   3          }
1173   2          if (gCtrlPara.U_Positive == 0x005A)
1174   2          {
1175   3      
1176   3            sys_read_vp(0x2012, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1177   3            if (gCtrlPara.U_Positive == 0x005A)
1178   3            {
1179   4              Send_ModBus(0x05, 0x0016, 0x0000, 0x00); // 下发触控
1180   4              gCtrlPara.U_Positive = 0;
1181   4              sys_write_vp(0x2012, (u8 *)&gCtrlPara.U_Positive, 1); // 触控清零
1182   4            }
1183   3          }
1184   2      
1185   2          // U轴负(第一次)
1186   2          for (i = 0; i < 5; i++)
1187   2          {
1188   3            sys_read_vp(0x2013, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1189   3          }
1190   2          if (gCtrlPara.U_Peverse == 0x005A)
1191   2          {
1192   3            sys_read_vp(0x2013, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1193   3            if (gCtrlPara.U_Peverse == 0x005A)
1194   3            {
1195   4              Send_ModBus(0x05, 0x0017, 0xFF00, 0x00); // 下发触控
1196   4              gCtrlPara.U_Peverse = 0;
1197   4              sys_write_vp(0x2013, (u8 *)&gCtrlPara.U_Peverse, 1); // 触控清零
1198   4      
1199   4              gCtrlPara.SendFlag = 1;
1200   4            }
1201   3          }
1202   2      
1203   2          // U轴负（松开）
1204   2          for (i = 0; i < 5; i++)
1205   2          {
1206   3            sys_read_vp(0x2014, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1207   3          }
1208   2          if (gCtrlPara.U_Peverse == 0x005A)
1209   2          {
1210   3            sys_read_vp(0x2014, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1211   3            if (gCtrlPara.U_Peverse == 0x005A)
1212   3            {
1213   4              Send_ModBus(0x05, 0x0017, 0x0000, 0x00); // 下发触控
1214   4              gCtrlPara.U_Peverse = 0;
1215   4              sys_write_vp(0x2014, (u8 *)&gCtrlPara.U_Peverse, 1); // 触控清零
1216   4            }
1217   3          }
1218   2        }
1219   1      }
1220          
1221          void Touch_Scan_6(void)
1222          {
1223   1        u8 i;
1224   1        gCtrlPara.FileFlag = 0; // 读文件标志
1225   1      
1226   1        // 走边框  //0x1018
1227   1        for (i = 0; i < 5; i++)
1228   1        {
1229   2          sys_read_vp(HMI_Go_Border, (u8 *)&gCtrlPara.Go_Border, 1); // 读触控
1230   2        }
1231   1        if (gCtrlPara.Go_Border == 0x005A)
1232   1        {
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 21  

1233   2          sys_read_vp(HMI_Go_Border, (u8 *)&gCtrlPara.Go_Border, 1); // 读触控
1234   2          if (gCtrlPara.Go_Border == 0x005A)
1235   2          {
1236   3            gCtrlPara.TouchFlag = 1;
1237   3            HOST_Addr = HMI_Go_Border;
1238   3            gCtrlPara.GO_Focusing = 1;
1239   3      
1240   3            Send_ModBus(0x05, HOST_Start_Go_Border, 0xFF00, 0x00); // 下发触控
1241   3            gCtrlPara.Go_Border = 0;
1242   3            sys_write_vp(HMI_Go_Border, (u8 *)&gCtrlPara.Go_Border, 1); // 触控清零
1243   3          }
1244   2        }
1245   1      
1246   1        // 定位点101B
1247   1        for (i = 0; i < 5; i++)
1248   1        {
1249   2          sys_read_vp(HMI_Anchor_Point, (u8 *)&gCtrlPara.Anchor_Point, 1); // 读触控
1250   2        }
1251   1        if (gCtrlPara.Anchor_Point == 0x005A)
1252   1        {
1253   2          sys_read_vp(HMI_Anchor_Point, (u8 *)&gCtrlPara.Anchor_Point, 1); // 读触控
1254   2          if (gCtrlPara.Anchor_Point == 0x005A)
1255   2          {
1256   3            Send_ModBus(0x05, HOST_Anchor_Point, 0xFF00, 0x00); // 下发触控
1257   3            gCtrlPara.Anchor_Point = 0;
1258   3            sys_write_vp(HMI_Anchor_Point, (u8 *)&gCtrlPara.Anchor_Point, 1); // 触控清零
1259   3          }
1260   2        }
1261   1      
1262   1        // 启动/暂停 start/pause
1263   1        for (i = 0; i < 5; i++)
1264   1        {
1265   2          sys_read_vp(HMI_Start_Stoptouch, (u8 *)&gCtrlPara.Start_Stoptouch, 1); // 读触控
1266   2        }
1267   1        if (gCtrlPara.Start_Stoptouch == 0x5A)
1268   1        {
1269   2          sys_read_vp(HMI_Start_Stoptouch, (u8 *)&gCtrlPara.Start_Stoptouch, 1); // 读触控
1270   2          if (gCtrlPara.Start_Stoptouch == 0x5A)
1271   2          {
1272   3            Send_ModBus(0x05, 0x0000, 0xFF00, 0x00); // 下发触控
1273   3            gCtrlPara.Start_Stoptouch = 0;
1274   3            sys_write_vp(HMI_Start_Stoptouch, (u8 *)&gCtrlPara.Start_Stoptouch, 1); // 触控清零
1275   3      
1276   3            gCtrlPara.SendFlag = 1;
1277   3            if ((gCtrlPara.WorkSta == 0) || (gCtrlPara.WorkSta == 3) || (gCtrlPara.WorkSta == 5))
1278   3            {
1279   4              //                      gCtrlPara.WorkSta = 1;//运行
1280   4              gCtrlPara.Start_Stop = 1;
1281   4              sys_write_vp(HMI_Start_Stop, (u8 *)&gCtrlPara.Start_Stop, 1); // 图标显示
1282   4            }
1283   3            else
1284   3            {
1285   4              //                      gCtrlPara.WorkSta = 3;//暂停
1286   4              gCtrlPara.Start_Stop = 0;
1287   4              sys_write_vp(HMI_Start_Stop, (u8 *)&gCtrlPara.Start_Stop, 1); // 图标显示
1288   4            }
1289   3          }
1290   2        }
1291   1      
1292   1        // 停止(工作状态为空闲) stop (working status is idle)
1293   1        for (i = 0; i < 5; i++)
1294   1        {
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 22  

1295   2          sys_read_vp(HMI_Stop, (u8 *)&gCtrlPara.Stop, 1); // 读触控
1296   2        }
1297   1        if (gCtrlPara.Stop == 1)
1298   1        {
1299   2          sys_read_vp(HMI_Stop, (u8 *)&gCtrlPara.Stop, 1); // 读触控
1300   2          if (gCtrlPara.Stop == 1)
1301   2          {
1302   3            Send_ModBus(0x05, 0x0003, 0xFF00, 0x00); // 下发触控
1303   3            gCtrlPara.Stop = 0;
1304   3            sys_write_vp(HMI_Stop, (u8 *)&gCtrlPara.Stop, 1); // 触控清零
1305   3            gCtrlPara.SendFlag = 1;
1306   3      
1307   3            gCtrlPara.Start_Stop = 0;
1308   3            sys_write_vp(HMI_Start_Stop, (u8 *)&gCtrlPara.Start_Stop, 1); // 图标显示
1309   3      
1310   3            gCtrlPara.WorkTimeH = 0;
1311   3            sys_write_vp(HMI_Work_TimeC, (u8 *)&gCtrlPara.WorkTimeH, 1);
1312   3            gCtrlPara.WorkTimeM = 0;
1313   3            sys_write_vp(HMI_Work_TimeD, (u8 *)&gCtrlPara.WorkTimeM, 1);
1314   3            gCtrlPara.WorkTimeS = 0;
1315   3            sys_write_vp(HMI_Work_TimeE, (u8 *)&gCtrlPara.WorkTimeS, 1);
1316   3      
1317   3            gCtrlPara.Processing_Speed = 0;
1318   3            sys_write_vp(HMI_Processing_Speed, (u8 *)&gCtrlPara.Processing_Speed, 1); // 加工速度显示
1319   3      
1320   3            Page_Change(0x01);
1321   3      
1322   3            //                    gCtrlPara.Cartoon = 0;//动画
1323   3            //                    sys_write_vp(HMI_Cartoon,(u8*)&gCtrlPara.Cartoon,1);//动画停止
1324   3      
1325   3            gCtrlPara.GO_Focusing = 0; // 走边框-寻焦
1326   3          }
1327   2        }
1328   1      
1329   1        /**********************************************************************************/
1330   1        if (gCtrlPara.Shake_handFlag == 1) // 握手成功读取数据
1331   1        {
1332   2          /* Get Nudge Value */
1333   2          for (i = 0; i < 5; i++)
1334   2          {
1335   3            sys_read_vp(HMI_Nudge_Addr, (u8 *)&gCtrlPara.nudgeVal, 1);
1336   3          }
1337   2          
1338   2          /* Arrow Keys Continuous Press Check */
1339   2          if (GetTimeOutFlag(ARROW_KEYS_TIMER_NO) && (gCtrlPara.arrowContPressFlag == 0))
1340   2          {
1341   3            Send_ModBus(0x05, gCtrlPara.arrowLastPressVal, 0xFF00, 0x00); // 下发触控
1342   3            delay_ms(gCtrlPara.nudgeVal);
1343   3            gCtrlPara.arrowContPressFlag = 1;
1344   3          }
1345   2      
1346   2          // 上(第一次) Up First Press
1347   2          for (i = 0; i < 5; i++)
1348   2          {
1349   3            sys_read_vp(0x2002, (u8 *)&gCtrlPara.On, 1); // 读触控
1350   3          }
1351   2          if (gCtrlPara.On == 0x005A)
1352   2          {
1353   3            sys_read_vp(0x2002, (u8 *)&gCtrlPara.On, 1); // 读触控
1354   3            if (gCtrlPara.On == 0x005A)
1355   3            {
1356   4              Send_ModBus(0x05, 0x0004, 0xFF00, 0x00); // 下发触控
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 23  

1357   4              delay_ms(gCtrlPara.nudgeVal);
1358   4              Send_ModBus(0x05, 0x0004, 0x0000, 0x00);
1359   4              gCtrlPara.On = 0;
1360   4              sys_write_vp(0x2002, (u8 *)&gCtrlPara.On, 1); // 触控清零
1361   4      
1362   4              gCtrlPara.arrowContPressFlag = 0;
1363   4              gCtrlPara.arrowLastPressVal = 0x0004;
1364   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
1365   4              gCtrlPara.SendFlag = 1;
1366   4            }
1367   3          }
1368   2      
1369   2          // 上（松开） Up Release
1370   2          for (i = 0; i < 5; i++)
1371   2          {
1372   3            sys_read_vp(0x2003, (u8 *)&gCtrlPara.On, 1); // 读触控
1373   3          }
1374   2          if (gCtrlPara.On == 0x005A)
1375   2          {
1376   3            sys_read_vp(0x2003, (u8 *)&gCtrlPara.On, 1); // 读触控
1377   3            if (gCtrlPara.On == 0x005A)
1378   3            {
1379   4              KillTimer(ARROW_KEYS_TIMER_NO);
1380   4              gCtrlPara.arrowLastPressVal = 0;
1381   4              gCtrlPara.arrowContPressFlag = 0;
1382   4              Send_ModBus(0x05, 0x0004, 0x0000, 0x00); // 下发触控
1383   4              gCtrlPara.On = 0;
1384   4              sys_write_vp(0x2003, (u8 *)&gCtrlPara.On, 1); // 触控清零
1385   4            }
1386   3          }
1387   2      
1388   2          // 下(第一次) Down First Press
1389   2          for (i = 0; i < 5; i++)
1390   2          {
1391   3            sys_read_vp(0x2004, (u8 *)&gCtrlPara.Under, 1); // 读触控
1392   3          }
1393   2          if (gCtrlPara.Under == 0x005A)
1394   2          {
1395   3            sys_read_vp(0x2004, (u8 *)&gCtrlPara.Under, 1); // 读触控
1396   3            if (gCtrlPara.Under == 0x005A)
1397   3            {
1398   4              Send_ModBus(0x05, 0x0005, 0xFF00, 0x00); // 下发触控
1399   4              delay_ms(gCtrlPara.nudgeVal);
1400   4              Send_ModBus(0x05, 0x0005, 0x0000, 0x00);
1401   4              gCtrlPara.Under = 0;
1402   4              sys_write_vp(0x2004, (u8 *)&gCtrlPara.Under, 1); // 触控清零
1403   4      
1404   4              gCtrlPara.arrowContPressFlag = 0;
1405   4              gCtrlPara.arrowLastPressVal = 0x0005;
1406   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
1407   4              gCtrlPara.SendFlag = 1;
1408   4            }
1409   3          }
1410   2      
1411   2          // 下（松开） Down Release
1412   2          for (i = 0; i < 5; i++)
1413   2          {
1414   3            sys_read_vp(0x2005, (u8 *)&gCtrlPara.Under, 1); // 读触控
1415   3          }
1416   2          if (gCtrlPara.Under == 0x005A)
1417   2          {
1418   3            sys_read_vp(0x2005, (u8 *)&gCtrlPara.Under, 1); // 读触控
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 24  

1419   3            if (gCtrlPara.Under == 0x005A)
1420   3            {
1421   4              KillTimer(ARROW_KEYS_TIMER_NO);
1422   4              gCtrlPara.arrowLastPressVal = 0;
1423   4              gCtrlPara.arrowContPressFlag = 0;
1424   4              Send_ModBus(0x05, 0x0005, 0x0000, 0x00); // 下发触控
1425   4              gCtrlPara.Under = 0;
1426   4              sys_write_vp(0x2005, (u8 *)&gCtrlPara.Under, 1); // 触控清零
1427   4            }
1428   3          }
1429   2      
1430   2          // 左(第一次) Left First Press
1431   2          for (i = 0; i < 5; i++)
1432   2          {
1433   3            sys_read_vp(0x2006, (u8 *)&gCtrlPara.Left, 1); // 读触控
1434   3          }
1435   2          if (gCtrlPara.Left == 0x005A)
1436   2          {
1437   3            sys_read_vp(0x2006, (u8 *)&gCtrlPara.Left, 1); // 读触控
1438   3            if (gCtrlPara.Left == 0x005A)
1439   3            {
1440   4              Send_ModBus(0x05, 0x0006, 0xFF00, 0x00); // 下发触控
1441   4              delay_ms(gCtrlPara.nudgeVal);
1442   4              Send_ModBus(0x05, 0x0006, 0x0000, 0x00);
1443   4              gCtrlPara.Left = 0;
1444   4              sys_write_vp(0x2006, (u8 *)&gCtrlPara.Left, 1); // 触控清零
1445   4      
1446   4              gCtrlPara.arrowContPressFlag = 0;
1447   4              gCtrlPara.arrowLastPressVal = 0x0006;
1448   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
1449   4              gCtrlPara.SendFlag = 1;
1450   4            }
1451   3          }
1452   2      
1453   2          // 左（松开） Left Release
1454   2          for (i = 0; i < 5; i++)
1455   2          {
1456   3            sys_read_vp(0x2007, (u8 *)&gCtrlPara.Left, 1); // 读触控
1457   3          }
1458   2          if (gCtrlPara.Left == 0x005A)
1459   2          {
1460   3            sys_read_vp(0x2007, (u8 *)&gCtrlPara.Left, 1); // 读触控
1461   3            if (gCtrlPara.Left == 0x005A)
1462   3            {
1463   4              KillTimer(ARROW_KEYS_TIMER_NO);
1464   4              gCtrlPara.arrowLastPressVal = 0;
1465   4              gCtrlPara.arrowContPressFlag = 0;
1466   4              Send_ModBus(0x05, 0x0006, 0x0000, 0x00); // 下发触控
1467   4              gCtrlPara.Left = 0;
1468   4              sys_write_vp(0x2007, (u8 *)&gCtrlPara.Left, 1); // 触控清零
1469   4            }
1470   3          }
1471   2      
1472   2          // 右(第一次) Right First Press
1473   2          for (i = 0; i < 5; i++)
1474   2          {
1475   3            sys_read_vp(0x2008, (u8 *)&gCtrlPara.Right, 1); // 读触控
1476   3          }
1477   2          if (gCtrlPara.Right == 0x005A)
1478   2          {
1479   3            sys_read_vp(0x2008, (u8 *)&gCtrlPara.Right, 1); // 读触控
1480   3            if (gCtrlPara.Right == 0x005A)
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 25  

1481   3            {
1482   4              Send_ModBus(0x05, 0x0007, 0xFF00, 0x00); // 下发触控
1483   4              delay_ms(gCtrlPara.nudgeVal);
1484   4              Send_ModBus(0x05, 0x0007, 0x0000, 0x00);
1485   4              gCtrlPara.Right = 0;
1486   4              sys_write_vp(0x2008, (u8 *)&gCtrlPara.Right, 1); // 触控清零
1487   4      
1488   4              gCtrlPara.arrowContPressFlag = 0;
1489   4              gCtrlPara.arrowLastPressVal = 0x0007;
1490   4              StartTimer(ARROW_KEYS_TIMER_NO, ARROW_KEYS_TIMER_CNT);
1491   4              gCtrlPara.SendFlag = 1;
1492   4            }
1493   3          }
1494   2      
1495   2          // 右（松开） Right Release
1496   2          for (i = 0; i < 5; i++)
1497   2          {
1498   3            sys_read_vp(0x2009, (u8 *)&gCtrlPara.Right, 1); // 读触控
1499   3          }
1500   2          if (gCtrlPara.Right == 0x005A)
1501   2          {
1502   3            sys_read_vp(0x2009, (u8 *)&gCtrlPara.Right, 1); // 读触控
1503   3            if (gCtrlPara.Right == 0x005A)
1504   3            {
1505   4              KillTimer(ARROW_KEYS_TIMER_NO);
1506   4              gCtrlPara.arrowLastPressVal = 0;
1507   4              gCtrlPara.arrowContPressFlag = 0;
1508   4              Send_ModBus(0x05, 0x0007, 0x0000, 0x00); // 下发触控
1509   4              gCtrlPara.Right = 0;
1510   4              sys_write_vp(0x2009, (u8 *)&gCtrlPara.Right, 1); // 触控清零
1511   4            }
1512   3          }
1513   2      
1514   2          // Z轴正(第一次)
1515   2          for (i = 0; i < 5; i++)
1516   2          {
1517   3            sys_read_vp(0x200D, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1518   3          }
1519   2          if (gCtrlPara.Z_Positive == 0x005A)
1520   2          {
1521   3            sys_read_vp(0x200D, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1522   3            if (gCtrlPara.Z_Positive == 0x005A)
1523   3            {
1524   4              Send_ModBus(0x05, 0x0014, 0xFF00, 0x00); // 下发触控
1525   4              gCtrlPara.Z_Positive = 0;
1526   4              sys_write_vp(0x200D, (u8 *)&gCtrlPara.Z_Positive, 1); // 触控清零
1527   4      
1528   4              gCtrlPara.SendFlag = 1;
1529   4            }
1530   3          }
1531   2      
1532   2          // Z轴正（松开）
1533   2          for (i = 0; i < 5; i++)
1534   2          {
1535   3            sys_read_vp(0x200E, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1536   3          }
1537   2          if (gCtrlPara.Z_Positive == 0x005A)
1538   2          {
1539   3            sys_read_vp(0x200E, (u8 *)&gCtrlPara.Z_Positive, 1); // 读触控
1540   3            if (gCtrlPara.Z_Positive == 0x005A)
1541   3            {
1542   4              Send_ModBus(0x05, 0x0014, 0x0000, 0x00); // 下发触控
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 26  

1543   4              gCtrlPara.Z_Positive = 0;
1544   4              sys_write_vp(0x200E, (u8 *)&gCtrlPara.Z_Positive, 1); // 触控清零
1545   4            }
1546   3          }
1547   2      
1548   2          // Z轴负(第一次)
1549   2          for (i = 0; i < 5; i++)
1550   2          {
1551   3            sys_read_vp(0x200F, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1552   3          }
1553   2          if (gCtrlPara.Z_Peverse == 0x005A)
1554   2          {
1555   3            sys_read_vp(0x200F, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1556   3            if (gCtrlPara.Z_Peverse == 0x005A)
1557   3            {
1558   4              Send_ModBus(0x05, 0x0015, 0xFF00, 0x00); // 下发触控
1559   4              gCtrlPara.Z_Peverse = 0;
1560   4              sys_write_vp(0x200F, (u8 *)&gCtrlPara.Z_Peverse, 1); // 触控清零
1561   4      
1562   4              gCtrlPara.SendFlag = 1;
1563   4            }
1564   3          }
1565   2      
1566   2          // Z轴负（松开）
1567   2          for (i = 0; i < 5; i++)
1568   2          {
1569   3            sys_read_vp(0x2010, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1570   3          }
1571   2          if (gCtrlPara.Z_Peverse == 0x005A)
1572   2          {
1573   3            sys_read_vp(0x2010, (u8 *)&gCtrlPara.Z_Peverse, 1); // 读触控
1574   3            if (gCtrlPara.Z_Peverse == 0x005A)
1575   3            {
1576   4              Send_ModBus(0x05, 0x0015, 0x0000, 0x00); // 下发触控
1577   4              gCtrlPara.Z_Peverse = 0;
1578   4              sys_write_vp(0x2010, (u8 *)&gCtrlPara.Z_Peverse, 1); // 触控清零
1579   4            }
1580   3          }
1581   2      
1582   2          // U轴正(第一次)
1583   2          for (i = 0; i < 5; i++)
1584   2          {
1585   3            sys_read_vp(0x2011, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1586   3          }
1587   2          if (gCtrlPara.U_Positive == 0x005A)
1588   2          {
1589   3            sys_read_vp(0x2011, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1590   3            if (gCtrlPara.U_Positive == 0x005A)
1591   3            {
1592   4              Send_ModBus(0x05, 0x0016, 0xFF00, 0x00); // 下发触控
1593   4              gCtrlPara.U_Positive = 0;
1594   4              sys_write_vp(0x2011, (u8 *)&gCtrlPara.U_Positive, 1); // 触控清零
1595   4      
1596   4              gCtrlPara.SendFlag = 1;
1597   4            }
1598   3          }
1599   2      
1600   2          // U轴正（松开）
1601   2          for (i = 0; i < 5; i++)
1602   2          {
1603   3            sys_read_vp(0x2012, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1604   3          }
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 27  

1605   2          if (gCtrlPara.U_Positive == 0x005A)
1606   2          {
1607   3      
1608   3            sys_read_vp(0x2012, (u8 *)&gCtrlPara.U_Positive, 1); // 读触控
1609   3            if (gCtrlPara.U_Positive == 0x005A)
1610   3            {
1611   4              Send_ModBus(0x05, 0x0016, 0x0000, 0x00); // 下发触控
1612   4              gCtrlPara.U_Positive = 0;
1613   4              sys_write_vp(0x2012, (u8 *)&gCtrlPara.U_Positive, 1); // 触控清零
1614   4            }
1615   3          }
1616   2      
1617   2          // U轴负(第一次)
1618   2          for (i = 0; i < 5; i++)
1619   2          {
1620   3            sys_read_vp(0x2013, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1621   3          }
1622   2          if (gCtrlPara.U_Peverse == 0x005A)
1623   2          {
1624   3            sys_read_vp(0x2013, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1625   3            if (gCtrlPara.U_Peverse == 0x005A)
1626   3            {
1627   4              Send_ModBus(0x05, 0x0017, 0xFF00, 0x00); // 下发触控
1628   4              gCtrlPara.U_Peverse = 0;
1629   4              sys_write_vp(0x2013, (u8 *)&gCtrlPara.U_Peverse, 1); // 触控清零
1630   4      
1631   4              gCtrlPara.SendFlag = 1;
1632   4            }
1633   3          }
1634   2      
1635   2          // U轴负（松开）
1636   2          for (i = 0; i < 5; i++)
1637   2          {
1638   3            sys_read_vp(0x2014, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1639   3          }
1640   2          if (gCtrlPara.U_Peverse == 0x005A)
1641   2          {
1642   3            sys_read_vp(0x2014, (u8 *)&gCtrlPara.U_Peverse, 1); // 读触控
1643   3            if (gCtrlPara.U_Peverse == 0x005A)
1644   3            {
1645   4              Send_ModBus(0x05, 0x0017, 0x0000, 0x00); // 下发触控
1646   4              gCtrlPara.U_Peverse = 0;
1647   4              sys_write_vp(0x2014, (u8 *)&gCtrlPara.U_Peverse, 1); // 触控清零
1648   4            }
1649   3          }
1650   2        }
1651   1      }
1652          
1653          void Touch_Scan_10_12(void)
1654          {
1655   1      
1656   1        u8 i;
1657   1        for (i = 0; i < 5; i++)
1658   1        {
1659   2          sys_read_vp(0x10B1, (u8 *)&gCtrlPara.Icon_Init, 1); // 读触控
1660   2        }
1661   1        if (gCtrlPara.Icon_Init != gCtrlPara.Icon_InitHis)
1662   1        {
1663   2          sys_read_vp(0x10B1, (u8 *)&gCtrlPara.Icon_Init, 1); // 读触控
1664   2          if (gCtrlPara.Icon_Init != gCtrlPara.Icon_InitHis)
1665   2          {
1666   3      
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 28  

1667   3            if (gCtrlPara.Icon_Init == 1)
1668   3            {
1669   4              HOST_Addr = 0x0051;
1670   4              Send_ModBus_10(0x10, 0x0051, 0x01, gCtrlPara.Icon_Init, 0x2);
1671   4              delay_ms(5);
1672   4              Send_ModBus(0x03, 0x0051, 0x0000, 0x01); // 下发触控
1673   4            }
1674   3            else if (gCtrlPara.Icon_Init == 2)
1675   3            {
1676   4              HOST_Addr = 0x0052;
1677   4              Send_ModBus_10(0x10, 0x0052, 0x01, gCtrlPara.Icon_Init, 0x2);
1678   4      
1679   4              delay_ms(5);
1680   4              Send_ModBus(0x03, 0x0052, 0x0000, 0x01); // 下发触控
1681   4            }
1682   3            else if (gCtrlPara.Icon_Init == 3)
1683   3            {
1684   4              HOST_Addr = 0x0053;
1685   4              Send_ModBus_10(0x10, 0x0053, 0x01, gCtrlPara.Icon_Init, 0x2);
1686   4      
1687   4              delay_ms(5);
1688   4              Send_ModBus(0x03, 0x0053, 0x0000, 0x01); // 下发触控
1689   4            }
1690   3            else if (gCtrlPara.Icon_Init == 4)
1691   3            {
1692   4              HOST_Addr = 0x0054;
1693   4              Send_ModBus_10(0x10, 0x0054, 0x01, gCtrlPara.Icon_Init, 0x2);
1694   4      
1695   4              delay_ms(5);
1696   4              Send_ModBus(0x03, 0x0054, 0x0000, 0x01); // 下发触控
1697   4            }
1698   3            else if (gCtrlPara.Icon_Init == 5)
1699   3            {
1700   4              HOST_Addr = 0x0055;
1701   4              Send_ModBus_10(0x10, 0x0055, 0x01, gCtrlPara.Icon_Init, 0x2);
1702   4      
1703   4              delay_ms(5);
1704   4              Send_ModBus(0x03, 0x0055, 0x0000, 0x01); // 下发触控
1705   4            }
1706   3            else if (gCtrlPara.Icon_Init == 6)
1707   3            {
1708   4              HOST_Addr = 0x0056;
1709   4              Send_ModBus_10(0x10, 0x0056, 0x01, gCtrlPara.Icon_Init, 0x2);
1710   4      
1711   4              delay_ms(5);
1712   4              Send_ModBus(0x03, 0x0056, 0x0000, 0x01); // 下发触控
1713   4            }
1714   3      
1715   3            sys_write_vp(0x10B1, (u8 *)&gCtrlPara.Icon_InitHis, 1); // 触控清零
1716   3          }
1717   2        }
1718   1      }
1719          
1720          // void Touch_Scan_10_12(void)
1721          //{
1722          //  u8 i;
1723          // 语言
1724          //            for(i = 0;i < 10;i++)
1725          //            {
1726          //              sys_read_vp(HMI_Read_Language_Enter,(u8*)&gCtrlPara.Language_Enter,1);  //读触控
1727          //            }
1728          //            if(gCtrlPara.Language_Enter == 0x01)
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 29  

1729          //            {
1730          //              sys_read_vp(HMI_Read_Language_Enter,(u8*)&gCtrlPara.Language_Enter,1);  //读触控
1731          //              if(gCtrlPara.Language_Enter == 0x01)
1732          //              {
1733          //                sys_read_vp(HMI_Read_Language,(u8*)&gCtrlPara.Language,1);
1734          //                Write_Nor_Flash();
1735          //                sys_delay_ms(1);
1736          //                if(gCtrlPara.Language == 0)
1737          //                  Change_Page(0x06);
1738          //                else
1739          //                  Change_Page(0x1F);
1740          //                sys_write_vp(HMI_Read_Language,(u8*)&gCtrlPara.Language,1);
1741          //
1742          //                gCtrlPara.Language_Enter = 0;
1743          //                sys_write_vp(HMI_Read_Language_Enter,(u8*)&gCtrlPara.Language_Enter,1);//触控清零
1744          //              }
1745          //            }
1746          //}
1747          void Touch_Scan_13(void)
1748          {
1749   1        u8 i;
1750   1        if (gCtrlPara.LED_NOWFlag == 1)
1751   1        {
1752   2          for (i = 0; i < 5; i++)
1753   2          {
1754   3            sys_read_vp(LED_NOW, (u8 *)&gCtrlPara.Value, 1); // 读取当前亮度
1755   3          }
1756   2          gCtrlPara.Value = gCtrlPara.Value & 0x00FF;
1757   2      
1758   2          if ((gCtrlPara.Value > 0) && (gCtrlPara.Value <= 0x14))
1759   2          {
1760   3            gCtrlPara.Data = 0x0001;
1761   3            sys_write_vp(0x10A8, (u8 *)&gCtrlPara.Data, 1);
1762   3          }
1763   2          else if ((gCtrlPara.Value > 0x14) && (gCtrlPara.Value <= 0x32))
1764   2          {
1765   3            gCtrlPara.Data = 0x0002;
1766   3            sys_write_vp(0x10A8, (u8 *)&gCtrlPara.Data, 1);
1767   3          }
1768   2          else if ((gCtrlPara.Value > 0x32) && (gCtrlPara.Value <= 0x64))
1769   2          {
1770   3            gCtrlPara.Data = 0x0003;
1771   3            sys_write_vp(0x10A8, (u8 *)&gCtrlPara.Data, 1);
1772   3          }
1773   2      
1774   2          gCtrlPara.LED_NOWFlag = 0;
1775   2        }
1776   1      
1777   1        for (i = 0; i < 5; i++)
1778   1        {
1779   2          sys_read_vp(0x20E0, (u8 *)&gCtrlPara.Value, 1); // 读触控
1780   2        }
1781   1        if (gCtrlPara.Value == 0x0001)
1782   1        {
1783   2          sys_read_vp(0x20E0, (u8 *)&gCtrlPara.Value, 1); // 读触控
1784   2          if (gCtrlPara.Value == 0x0001)
1785   2          {
1786   3      
1787   3            sys_read_vp(0x10A7, (u8 *)&gCtrlPara.Data, 1); // 读触控
1788   3            if (gCtrlPara.Data == 0)
1789   3            {
1790   4              sys_write_vp(0x3302, (u8 *)&gCtrlPara.Data, 1);
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 30  

1791   4            }
1792   3            else if (gCtrlPara.Data == 1)
1793   3            {
1794   4              sys_write_vp(0x3302, (u8 *)&gCtrlPara.Data, 1);
1795   4            }
1796   3      
1797   3            sys_read_vp(0x10A8, (u8 *)&gCtrlPara.Data, 1); // 读触控
1798   3            if (gCtrlPara.Data == 0x01)
1799   3            {
1800   4              gCtrlPara.Data = 0x1414;
1801   4              sys_write_vp(LED_CONFIG, (u8 *)&gCtrlPara.Data, 1);
1802   4            }
1803   3            else if (gCtrlPara.Data == 2)
1804   3            {
1805   4              gCtrlPara.Data = 0x3232;
1806   4              sys_write_vp(LED_CONFIG, (u8 *)&gCtrlPara.Data, 1);
1807   4            }
1808   3            else if (gCtrlPara.Data == 3)
1809   3            {
1810   4              gCtrlPara.Data = 0x6464;
1811   4              sys_write_vp(LED_CONFIG, (u8 *)&gCtrlPara.Data, 1);
1812   4            }
1813   3      
1814   3            gCtrlPara.Value = 0;
1815   3            sys_write_vp(0x20E0, (u8 *)&gCtrlPara.Value, 1); // 触控清零
1816   3          }
1817   2        }
1818   1      }
1819          
1820          void Touch_Scan_14(void)
1821          {
1822   1        u8 i;
1823   1        // 写IP
1824   1        for (i = 0; i < 5; i++)
1825   1        {
1826   2          sys_read_vp(HMI_Write_WIFI_IP, (u8 *)&gCtrlPara.Write_IP, 1); // 读触控
1827   2        }
1828   1        if (gCtrlPara.Write_IP == 0x0001)
1829   1        {
1830   2          sys_read_vp(HMI_Write_WIFI_IP, (u8 *)&gCtrlPara.Write_IP, 1); // 读触控
1831   2          if (gCtrlPara.Write_IP == 0x0001)
1832   2          {
1833   3            Send_ModBus_IP(); // 发送IP地址
1834   3            delay_ms(1);
1835   3            gCtrlPara.Write_IP = 0;
1836   3            sys_write_vp(HMI_Write_WIFI_IP, (u8 *)&gCtrlPara.Write_IP, 1); // 触控清零
1837   3          }
1838   2        }
1839   1      }
1840          
1841          void Touch_Scan_16(void)
1842          {
1843   1        u8 i;
1844   1        // 密码输入
1845   1        for (i = 0; i < 5; i++)
1846   1        {
1847   2          sys_read_vp(0x401F, (u8 *)&gCtrlPara.Value, 1); // 读触控
1848   2        }
1849   1        if (gCtrlPara.Value == 0x0001)
1850   1        {
1851   2          sys_read_vp(0x401F, (u8 *)&gCtrlPara.Value, 1); // 读触控
1852   2          if (gCtrlPara.Value == 0x0001)
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 31  

1853   2          {
1854   3            sys_read_vp(0x4020, (u8 *)&gCtrlPara.Data, 1);  // 读触控
1855   3            sys_read_vp(0x4021, (u8 *)&gCtrlPara.Data1, 1); // 读触控
1856   3            sys_read_vp(0x4022, (u8 *)&gCtrlPara.Data2, 1); // 读触控
1857   3            sys_read_vp(0x4023, (u8 *)&gCtrlPara.Data3, 1); // 读触控
1858   3      
1859   3            if ((gCtrlPara.Data == 1) && (gCtrlPara.Data1 == 2) && (gCtrlPara.Data2 == 3) && (gCtrlPara.Data3 == 3)
             -)
1860   3            {
1861   4              Page_Change(0x011);
1862   4            }
1863   3          }
1864   2        }
1865   1      }
1866          // void Touch_Scan_18(void)
1867          //{
1868          //      u8 i;
1869          //
1870          //            for(i = 0;i < 10;i++)
1871          //            {
1872          //              sys_read_vp(HMI_Keyboard_lock,(u8*)&gCtrlPara.Keyboard_lock,1); //读触控
1873          //            }
1874          //            if(gCtrlPara.Keyboard_lock == 0x01)
1875          //            {
1876          //              sys_read_vp(HMI_Keyboard_lock,(u8*)&gCtrlPara.Keyboard_lock,1); //读触控
1877          //              if(gCtrlPara.Keyboard_lock == 0x01)
1878          //              {
1879          //                sys_read_vp(HMI_Lock_pas_Addr1,(u8*)&gCtrlPara.Lock_password1,1);
1880          //                sys_read_vp(HMI_Lock_pas_Addr2,(u8*)&gCtrlPara.Lock_password2,1);
1881          //                sys_read_vp(HMI_Lock_pas_Addr3,(u8*)&gCtrlPara.Lock_password3,1);
1882          //                sys_read_vp(HMI_Lock_pas_Addr4,(u8*)&gCtrlPara.Lock_password4,1);
1883          
1884          //                Send_ModBus08_10(0x10,0x0417,0x04,gCtrlPara.Lock_password1,gCtrlPara.Lock_password2,gCtrlPara.Lo
             -ck_password3,gCtrlPara.Lock_password4,0x08);//下发时
1885          //
1886          //                gCtrlPara.Keyboard_lock = 0;
1887          //                sys_write_vp(HMI_Keyboard_lock,(u8*)&gCtrlPara.Keyboard_lock,1);//触控清零
1888          //
1889          //              }
1890          //            }
1891          //}
1892          
1893          // 坐标控制（文件确认和删除）
1894          void Coordinate_Control(void)
1895          {
1896   1        sys_read_vp(TP_STATUS, TP_Status_New, 4); // 读触控
1897   1        Read_StatusFlag = strcmp(TP_Status_New, TP_Status_Old);
1898   1        if (Read_StatusFlag)
1899   1        {
1900   2          if (TP_Status_New[1] == 0x02) // 抬起
1901   2          {
1902   3            gCtrlPara.Value_X = (TP_Status_New[2] << 8) + TP_Status_New[3];
1903   3            gCtrlPara.Value_Y = (TP_Status_New[4] << 8) + TP_Status_New[5];
1904   3      
1905   3            if ((gCtrlPara.Value_X <= 530) && (gCtrlPara.Value_X >= 460)) // 删除X(460-530)
1906   3            {
1907   4              // Y(210-320)110
1908   4              if ((gCtrlPara.Value_Y >= 210) && (gCtrlPara.Value_Y <= 320) && (gCtrlPara.File_IconNum == 1))
1909   4              {
1910   5                HOST_Addr = HMI_Delete;
1911   5                Send_ModBus_10(0x10, HOST_DeleteR, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1912   5      
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 32  

1913   5                delay_ms(5);
1914   5                gCtrlPara.FileFlag = 0; // 读文件标志
1915   5              }
1916   4      
1917   4              else if ((gCtrlPara.Value_Y >= 330) && (gCtrlPara.Value_Y <= 440) && (gCtrlPara.File_IconNum == 2))
1918   4              {
1919   5                HOST_Addr = HMI_Delete;
1920   5                Send_ModBus_10(0x10, HOST_DeleteR, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1921   5      
1922   5                delay_ms(5);
1923   5                gCtrlPara.FileFlag = 0; // 读文件标志
1924   5              }
1925   4              else if ((gCtrlPara.Value_Y >= 450) && (gCtrlPara.Value_Y <= 550) && (gCtrlPara.File_IconNum == 3))
1926   4              {
1927   5                HOST_Addr = HMI_Delete;
1928   5                Send_ModBus_10(0x10, HOST_DeleteR, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1929   5      
1930   5                delay_ms(5);
1931   5                gCtrlPara.FileFlag = 0; // 读文件标志
1932   5              }
1933   4              else if ((gCtrlPara.Value_Y >= 570) && (gCtrlPara.Value_Y <= 680) && (gCtrlPara.File_IconNum == 4))
1934   4              {
1935   5                HOST_Addr = HMI_Delete;
1936   5                Send_ModBus_10(0x10, HOST_DeleteR, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1937   5      
1938   5                delay_ms(5);
1939   5                gCtrlPara.FileFlag = 0; // 读文件标志
1940   5              }
1941   4              else if ((gCtrlPara.Value_Y >= 685) && (gCtrlPara.Value_Y <= 790) && (gCtrlPara.File_IconNum == 5))
1942   4              {
1943   5                HOST_Addr = HMI_Delete;
1944   5                Send_ModBus_10(0x10, HOST_DeleteR, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1945   5      
1946   5                delay_ms(5);
1947   5                gCtrlPara.FileFlag = 0; // 读文件标志
1948   5              }
1949   4              else if ((gCtrlPara.Value_Y >= 800) && (gCtrlPara.Value_Y <= 910) && (gCtrlPara.File_IconNum == 6))
1950   4              {
1951   5                HOST_Addr = HMI_Delete;
1952   5                Send_ModBus_10(0x10, HOST_DeleteR, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1953   5      
1954   5                delay_ms(5);
1955   5                gCtrlPara.FileFlag = 0; // 读文件标志
1956   5              }
1957   4              else if ((gCtrlPara.Value_Y >= 920) && (gCtrlPara.Value_Y <= 1030) && (gCtrlPara.File_IconNum == 7))
1958   4              {
1959   5                HOST_Addr = HMI_Delete;
1960   5                Send_ModBus_10(0x10, HOST_DeleteR, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1961   5      
1962   5                delay_ms(5);
1963   5                gCtrlPara.FileFlag = 0; // 读文件标志
1964   5              }
1965   4            }
1966   3            else if ((gCtrlPara.Value_X <= 680) && (gCtrlPara.Value_X > 570)) // X(570-680)确认
1967   3            {
1968   4              // Y(130-195)
1969   4              if ((gCtrlPara.Value_Y >= 210) && (gCtrlPara.Value_Y <= 320) && (gCtrlPara.File_IconNum == 1))
1970   4              {
1971   5                HOST_Addr = HMI_Confirm;
1972   5                Send_ModBus_10(0x10, HOST_Confirm, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1973   5                UART4_Sendbyte(0x01);
1974   5                Page_Change(0x01);
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 33  

1975   5              }
1976   4              // Y(205-270)
1977   4              else if ((gCtrlPara.Value_Y >= 330) && (gCtrlPara.Value_Y <= 440) && (gCtrlPara.File_IconNum == 2))
1978   4              {
1979   5                HOST_Addr = HMI_Confirm;
1980   5                Send_ModBus_10(0x10, HOST_Confirm, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1981   5      
1982   5                UART4_Sendbyte(0x02);
1983   5                Page_Change(0x01);
1984   5              }
1985   4              else if ((gCtrlPara.Value_Y >= 450) && (gCtrlPara.Value_Y <= 550) && (gCtrlPara.File_IconNum == 3))
1986   4              {
1987   5                HOST_Addr = HMI_Confirm;
1988   5                Send_ModBus_10(0x10, HOST_Confirm, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1989   5                UART4_Sendbyte(0x03);
1990   5                Page_Change(0x01);
1991   5              }
1992   4              else if ((gCtrlPara.Value_Y >= 570) && (gCtrlPara.Value_Y <= 680) && (gCtrlPara.File_IconNum == 4))
1993   4              {
1994   5                HOST_Addr = HMI_Confirm;
1995   5                Send_ModBus_10(0x10, HOST_Confirm, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
1996   5                UART4_Sendbyte(0x01);
1997   5                Page_Change(0x01);
1998   5              }
1999   4              else if ((gCtrlPara.Value_Y >= 685) && (gCtrlPara.Value_Y <= 790) && (gCtrlPara.File_IconNum == 5))
2000   4              {
2001   5                HOST_Addr = HMI_Confirm;
2002   5                Send_ModBus_10(0x10, HOST_Confirm, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
2003   5                UART4_Sendbyte(0x01);
2004   5                Page_Change(0x01);
2005   5              }
2006   4              else if ((gCtrlPara.Value_Y >= 800) && (gCtrlPara.Value_Y <= 910) && (gCtrlPara.File_IconNum == 6))
2007   4              {
2008   5                HOST_Addr = HMI_Confirm;
2009   5                Send_ModBus_10(0x10, HOST_Confirm, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
2010   5                UART4_Sendbyte(0x01);
2011   5                Page_Change(0x01);
2012   5              }
2013   4              else if ((gCtrlPara.Value_Y >= 920) && (gCtrlPara.Value_Y <= 1030) && (gCtrlPara.File_IconNum == 7))
2014   4              {
2015   5                HOST_Addr = HMI_Confirm;
2016   5                Send_ModBus_10(0x10, HOST_Confirm, 0x1, gCtrlPara.File_Num, 0x2); // 下发文件号
2017   5                UART4_Sendbyte(0x01);
2018   5                Page_Change(0x01);
2019   5              }
2020   4            }
2021   3      
2022   3            //          for( i=0;i<9;i++)
2023   3            //          {
2024   3            //            UART4_Sendbyte(TP_Status_New[i]);
2025   3            //          }
2026   3          }
2027   2          memcpy(TP_Status_Old, TP_Status_New, sizeof(TP_Status_New)); //
2028   2        }
2029   1        else
2030   1        {
2031   2        }
2032   1      }
2033          
2034          // 内存控制
2035          void File_Control(void)
2036          {
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 34  

2037   1        u8 i;
2038   1      
2039   1        if (gCtrlPara.Memory == 0x0001) // 内存
2040   1        {
2041   2      
2042   2          if ((gCtrlPara.FileFlag == 0) || (gCtrlPara.FileFlag == 1) || (gCtrlPara.Current_Control != gCtrlPara.Cu
             -rrent_ControlHis))
2043   2          {
2044   3            //                      gTime6++;
2045   3            //                      if(gTime6 > 10)
2046   3            //                      {
2047   3            //                        gTime6 = 0;
2048   3      
2049   3            if (gCtrlPara.FileCount == 0)
2050   3            {
2051   4              // 文件总数
2052   4              HOST_Addr = HMI_Total_Files;
2053   4              Send_ModBus(0x03, HOST_Total_Files, 0x0000, 0x01);
2054   4            }
2055   3      
2056   3            if (gCtrlPara.Total_Files > 0) // 有文件
2057   3            {
2058   4              if ((gCtrlPara.Current_Control >= 1) && (gCtrlPara.Current_Control <= gCtrlPara.Integer))
2059   4              {
2060   5                switch (gCtrlPara.FileCount)
2061   5                {
2062   6                case 1:
2063   6                {
2064   7                  // 一号文件
2065   7                  gCtrlPara.Number++;
2066   7                  HOST_Addr = HMI_NowFile1;
2067   7                  Send_ModBus(0x03, HOST_NowFile1 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2068   7                  gTime9++;
2069   7                  if (gTime9 >= 1)
2070   7                  {
2071   8                    gTime9 = 0;
2072   8                    gCtrlPara.FileCount = 2;
2073   8                  }
2074   7                }
2075   6                break;
2076   6                case 2:
2077   6                {
2078   7                  // 二号文件
2079   7                  gCtrlPara.Number++;
2080   7                  HOST_Addr = HMI_NowFile2;
2081   7                  Send_ModBus(0x03, HOST_NowFile2 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2082   7                  gTime9++;
2083   7                  if (gTime9 >= 1)
2084   7                  {
2085   8                    gTime9 = 0;
2086   8                    gCtrlPara.FileCount = 3;
2087   8                  }
2088   7                }
2089   6                break;
2090   6      
2091   6                case 3:
2092   6                {
2093   7                  // 三号文件
2094   7                  gCtrlPara.Number++;
2095   7                  HOST_Addr = HMI_NowFile3;
2096   7                  Send_ModBus(0x03, HOST_NowFile3 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2097   7                  gTime9++;
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 35  

2098   7                  if (gTime9 >= 1)
2099   7                  {
2100   8                    gTime9 = 0;
2101   8                    gCtrlPara.FileCount = 4;
2102   8                  }
2103   7                }
2104   6                break;
2105   6                case 4:
2106   6                {
2107   7                  // 四号文件
2108   7                  gCtrlPara.Number++;
2109   7                  HOST_Addr = HMI_NowFile4;
2110   7                  Send_ModBus(0x03, HOST_NowFile4 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2111   7                  gTime9++;
2112   7                  if (gTime9 >= 1)
2113   7                  {
2114   8                    gTime9 = 0;
2115   8                    gCtrlPara.FileCount = 5;
2116   8                  }
2117   7                }
2118   6                break;
2119   6                case 5:
2120   6                {
2121   7                  // 五号文件
2122   7                  gCtrlPara.Number++;
2123   7                  HOST_Addr = HMI_NowFile5;
2124   7                  Send_ModBus(0x03, HOST_NowFile5 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2125   7                  gTime9++;
2126   7                  if (gTime9 >= 1)
2127   7                  {
2128   8                    gTime9 = 0;
2129   8                    gCtrlPara.FileCount = 6;
2130   8                  }
2131   7                }
2132   6                break;
2133   6                case 6:
2134   6                {
2135   7                  // 六号文件
2136   7                  gCtrlPara.Number++;
2137   7                  HOST_Addr = HMI_NowFile6;
2138   7                  Send_ModBus(0x03, HOST_NowFile6 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2139   7                  gTime9++;
2140   7                  if (gTime9 >= 1)
2141   7                  {
2142   8                    gTime9 = 0;
2143   8                    gCtrlPara.FileCount = 7;
2144   8                  }
2145   7                }
2146   6                break;
2147   6                case 7:
2148   6                {
2149   7                  // 七号文件
2150   7                  gCtrlPara.Number++;
2151   7                  HOST_Addr = HMI_NowFile7;
2152   7                  Send_ModBus(0x03, HOST_NowFile7 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2153   7                  gTime9++;
2154   7                  if (gTime9 >= 1)
2155   7                  {
2156   8                    gTime9 = 0;
2157   8                    gCtrlPara.FileCount = 8;
2158   8                  }
2159   7                }
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 36  

2160   6                break;
2161   6                case 8:
2162   6                {
2163   7                  gCtrlPara.Current_ControlHis = gCtrlPara.Current_Control;
2164   7      
2165   7                  gCtrlPara.FileFlag++;
2166   7                  if (gCtrlPara.FileFlag > 1)
2167   7                  {
2168   8                    gCtrlPara.FileFlag = 2;
2169   8                    //                                            gCtrlPara.Total_FilesHis = gCtrlPara.Total_Files;
2170   8                  }
2171   7      
2172   7                  gCtrlPara.Number = 0;
2173   7                  gCtrlPara.NumberHis = 0;
2174   7      
2175   7                  gCtrlPara.FileCount = 0;
2176   7                }
2177   6                break;
2178   6                }
2179   5              }
2180   4              else if ((gCtrlPara.Integer == 0) || ((gCtrlPara.Current_Control >= 1) && (gCtrlPara.Current_Control =
             -= (gCtrlPara.Integer + 1))))
2181   4              {
2182   5                if (gCtrlPara.FileCount > gCtrlPara.Remainder) // 步进值大于余数跳出
2183   5                {
2184   6                  gCtrlPara.Current_ControlHis = gCtrlPara.Current_Control;
2185   6      
2186   6                  gCtrlPara.FileFlag++;
2187   6                  if (gCtrlPara.FileFlag > 1)
2188   6                  {
2189   7                    gCtrlPara.FileFlag = 2;
2190   7                    //                                        gCtrlPara.Total_FilesHis = gCtrlPara.Total_Files;
2191   7                  }
2192   6      
2193   6                  gCtrlPara.Number = 0;
2194   6                  gCtrlPara.NumberHis = 0;
2195   6      
2196   6                  gCtrlPara.FileCount = 0;
2197   6                }
2198   5      
2199   5                switch (gCtrlPara.FileCount)
2200   5                {
2201   6                case 1:
2202   6                {
2203   7                  // 一号文件
2204   7                  gCtrlPara.Number++;
2205   7                  HOST_Addr = HMI_NowFile1;
2206   7                  Send_ModBus(0x03, HOST_NowFile1 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2207   7                  gTime9++;
2208   7                  if (gTime9 >= 1)
2209   7                  {
2210   8                    gTime9 = 0;
2211   8                    gCtrlPara.FileCount = 2;
2212   8                  }
2213   7                }
2214   6                break;
2215   6                case 2:
2216   6                {
2217   7                  // 二号文件
2218   7                  gCtrlPara.Number++;
2219   7                  HOST_Addr = HMI_NowFile2;
2220   7                  Send_ModBus(0x03, HOST_NowFile2 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 37  

2221   7                  gTime9++;
2222   7                  if (gTime9 >= 1)
2223   7                  {
2224   8                    gTime9 = 0;
2225   8                    gCtrlPara.FileCount = 3;
2226   8                  }
2227   7                }
2228   6                break;
2229   6                case 3:
2230   6                {
2231   7                  // 三号文件
2232   7                  gCtrlPara.Number++;
2233   7                  HOST_Addr = HMI_NowFile3;
2234   7                  Send_ModBus(0x03, HOST_NowFile3 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2235   7                  gTime9++;
2236   7                  if (gTime9 >= 1)
2237   7                  {
2238   8                    gTime9 = 0;
2239   8                    gCtrlPara.FileCount = 4;
2240   8                  }
2241   7                }
2242   6                break;
2243   6                case 4:
2244   6                {
2245   7                  // 四号文件
2246   7                  gCtrlPara.Number++;
2247   7                  HOST_Addr = HMI_NowFile4;
2248   7                  Send_ModBus(0x03, HOST_NowFile4 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2249   7                  gTime9++;
2250   7                  if (gTime9 >= 1)
2251   7                  {
2252   8                    gTime9 = 0;
2253   8                    gCtrlPara.FileCount = 5;
2254   8                  }
2255   7                }
2256   6                break;
2257   6                case 5:
2258   6                {
2259   7                  // 五号文件
2260   7                  gCtrlPara.Number++;
2261   7                  HOST_Addr = HMI_NowFile5;
2262   7                  Send_ModBus(0x03, HOST_NowFile5 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2263   7                  gTime9++;
2264   7                  if (gTime9 >= 1)
2265   7                  {
2266   8                    gTime9 = 0;
2267   8                    gCtrlPara.FileCount = 6;
2268   8                  }
2269   7                }
2270   6                break;
2271   6                case 6:
2272   6                {
2273   7                  // 六号文件
2274   7                  gCtrlPara.Number++;
2275   7                  HOST_Addr = HMI_NowFile6;
2276   7                  Send_ModBus(0x03, HOST_NowFile6 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2277   7                  gTime9++;
2278   7                  if (gTime9 >= 1)
2279   7                  {
2280   8                    gTime9 = 0;
2281   8                    gCtrlPara.FileCount = 7;
2282   8                  }
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 38  

2283   7                }
2284   6                break;
2285   6                case 7:
2286   6                {
2287   7                  // 七号文件
2288   7                  gCtrlPara.Number++;
2289   7                  HOST_Addr = HMI_NowFile7;
2290   7                  Send_ModBus(0x03, HOST_NowFile7 + gCtrlPara.Number_Control * 4 * 7, 0x0000, 0x04);
2291   7                  gTime9++;
2292   7                  if (gTime9 >= 1)
2293   7                  {
2294   8                    gTime9 = 0;
2295   8                    gCtrlPara.FileCount = 8;
2296   8                  }
2297   7                }
2298   6                break;
2299   6                }
2300   5              }
2301   4      
2302   4              if (gCtrlPara.FileFlag == 0)
2303   4              {
2304   5                if (gCtrlPara.NumberHis != gCtrlPara.Number) // 有文件
2305   5                {
2306   6                  for (i = 0; i < gCtrlPara.Number; i++)
2307   6                  {
2308   7                    gCtrlPara.File_Control = 0; // 文件控制
2309   7                    sys_write_vp(HMI_File_Control + i, (u8 *)&gCtrlPara.File_Control, 1);
2310   7      
2311   7                    sys_write_vp(HMI_File_Icon + i, (u8 *)&gCtrlPara.File_IconHis, 1); // 文件图标触控清零
2312   7                  }
2313   6                  for (i = 6; i >= gCtrlPara.Number; i--)
2314   6                  {
2315   7                    gCtrlPara.File_Control = 1; // 文件控制
2316   7                    sys_write_vp(HMI_File_Control + i, (u8 *)&gCtrlPara.File_Control, 1);
2317   7                  }
2318   6                  gCtrlPara.NumberHis = gCtrlPara.Number;
2319   6                }
2320   5              }
2321   4            }
2322   3            else
2323   3            {
2324   4              if (gCtrlPara.FileCount == 1)
2325   4              {
2326   5                // 没有文件
2327   5                for (i = 0; i < 7; i++)
2328   5                {
2329   6                  gCtrlPara.File_Control = 1; // 文件控制
2330   6                  sys_write_vp(HMI_File_Control + i, (u8 *)&gCtrlPara.File_Control, 1);
2331   6      
2332   6                  sys_write_vp(HMI_File_Icon + i, (u8 *)&gCtrlPara.File_IconHis, 1); // 文件图标触控清零
2333   6                }
2334   5      
2335   5                gCtrlPara.FileCount = 0;
2336   5              }
2337   4            }
2338   3          }
2339   2        }
2340   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  15602    ----
C51 COMPILER V9.60.0.0   UI                                                                12/22/2022 15:37:59 PAGE 39  

   CONSTANT SIZE    =     57    ----
   XDATA SIZE       =   ----      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
